\documentclass[11pt]{article}
\usepackage[fntef,hyperref]{ctexcap}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{soul}
\usepackage{amssymb}
%\usepackage{hyperref}
\usepackage{setspace}


\title{training-linux-all}
\author{xingjianwei}
\date{09 三月 2011}

\begin{document}

\maketitle

\setcounter{tocdepth}{3}
\tableofcontents
\vspace*{1cm}

\section{Linux 基础课程}
\label{sec-1}

课程目标：内容包含各种基础的linux概念和软件应用。
\subsection{GNU和Linux}
\label{sec-1.1}

GNU 项目，其发音为“guh-noo”，于1984年发起，目标是开发一个完整的 UNIX 类的操作系统――GNU 系统，它全部由自由软件组成。使用 Linux 内核的 GNU 操作系统变种已被广泛使用；尽管这些系统常冠以“Linux”，更准确的说它们应称为 GNU/Linux 系统。
GNU 项目和自由软件的理念紧密相连，它也是衍生自 GNU 的、诸如 Ubuntu 等项目的关键所在。

Linux 内核，其发音为 `lee-nucks'，是各种Linux发行版操作系统的心脏。内核是操作系统的重要组成部分，它是硬件和软件之间进行通讯的桥梁。
Linux 诞生于1991年，由芬兰学生 Linus Torvalds 发起。那时，它只能运行在 i386 系统上，实质上是个独立编写的 UNIX 内核之克隆，旨在充分利用当时全新的 i386 架构。
现如今 Linux 几乎能运行在所有现代架构之上，这要归功于来自世界各地的人们所付出的大量开发工作。
Linux内核不仅在技术上占有一席之地，还在意识上占有重要位置。有一整个社群的人相信自由软件的理念，并花费大量时间帮助开源技术，使之臻于完美。

Linux 操作系统是UNIX 操作系统的一种克隆系统。它诞生于1991 年的10 月5 日（这是第一次正式向外公布的时间）。以后借助于Internet 网络，并经过全世界各地计算机爱好者的共同努力下，现已成为今天世界上使用最多的一种UNIX 类操作系统，并且使用人数还在迅猛增长。Linux 操作系统的诞生、发展和成长过程始终依赖着以下五个重要支柱：UNIX 操作系统、MINIX 操作系统、GNU 计划、POSIX 标准和Internet 网络。

\begin{itemize}

 \item UNIX 操作系统 -- UNIX 于1969 年诞生在Bell 实验室。Linux 就是UNIX 的一种克隆系统。UNIX的重要性参见\href{UnixHistory.pdf}{《UNIX OS简史》}。

 \item MINIX 操作系统 -- Minix 操作系统也是UNIX 的一种克隆系统，它于1987 年由著名计算机教授Andrew S. Tanenbaum 开发完成。由于MINIX 系统的出现并且提供源代码(只能免费用于大学内)在全世界的大学中刮起了学习UNIX 系统旋风。Linux 刚开始就是参照Minix 系统于1991 年才开始开发。

 \item GNU 计划-- 开发Linux 操作系统，以及Linux 上所用大多数软件基本上都出自GNU 计划。Linux只是操作系统的一个内核，没有GNU 软件环境(比如说bash shell)，则Linux 将寸步难行。

 \item POSIX 标准 -- 该标准在推动Linux 操作系统以后朝着正规路上发展起着重要的作用。是Linux前进的灯塔。POSIX 表示可移植操作系统接口（Portable Operating System Interface ，缩写为 POSIX 是为了读音更像 UNIX）。电气和电子工程师协会（Institute of Electrical and Electronics Engineers，IEEE）最初开发 POSIX 标准，是为了提高 UNIX 环境下应用程序的可移植性。Linux基本上实现了POSIX兼容，但并没有参加正式的POSIX认证。Windows NT至少部分实现了POSIX兼容。

 \item INTERNET -- 如果没有Intenet 网，没有遍布全世界的无数计算机骇客的无私奉献，那么Linux最多只能发展到0.13(0.95)版的水平。

\end{itemize} % ends low level
\subsubsection{Linux 操作系统的诞生}
\label{sec-1.1.1}

1981 年IBM 公司推出享誉全球的微型计算机IBM PC。在1981-1991 年间，MS-DOS 操作系统一直是微型计算机上操作系统的主宰。此时计算机硬件价格虽然逐年下降，但软件价格仍然是居高不下。当时Apple 的MACs 操作系统可以说是性能最好的，但是其天价没人能够轻易靠近。

到1991 年，GNU 计划已经开发出了许多工具软件。最受期盼的Gnu C 编译器已经出现，但还没有开发出免费的GNU 操作系统。即使是MINIX 也开始有了版权，需要购买才能得到源代码。而GNU 的操作系统HURD 一直在开发之中，但并不能在几年内完成。对于Linus 来说，已经不能等待了。从1991 年4 月份起，他开始酝酿并着手编制自己的操作系统。刚开始，他的目的很简单，只是为了学习Intel 386 体系结构保护模式运行方式下的编程技术。但后来Linux 的发展却完全改变了初衷。

1991 年初，Linus 开始在一台386sx 兼容微机上学习minix 操作系统。通过学习，他逐渐不能满足minix 系统的现有性能，并开始酝酿开发一个新的免费操作系统。根据Linux 在comp.os.minix 新闻组上发布的消息，我们可以知道他逐步从学习minix 系统到开发自己的Linux 的过程。

从1991 年的4 月份开始，Linus 几乎花了全部时间研究386-minix 系统(hack the kernel)，并且尝试着移植GNU 的软件到该系统上(GNU gcc、bash、gdb 等)。并于4 月13 日在comp.os.minix 上发布说自己已经成功地将bash 移植到了minix 上，而且已经爱不释手、不能离开这个shell 软件了。

第一个与Linux 有关的消息是在1991 年7 月3 日在comp.os.minix 上发布的(当然此时还不存在Linux 这个名称，当时Linus 的脑子里想的可能是FREAX ，FREAX 的英文含义是怪诞的、怪物、异想天开等)。其中透露了他正在进行Linux 系统的开发，并且在Linux 最初的时候已经想到要实现与POSIX（UNIX 的国际标准）的兼容问题了。

在Linus 的下一发布的消息中(1991 年8 月25 日 comp.os.minix)，他向所有minix 用户询问"What would you like to see in minix?"("你最想在minix 中见到什么？")，在该消息中他首次透露出正在开发一个(免费的)386(486)操作系统，并且说只是兴趣而已，代码不会很大，也不会象GNU 的那样专业。开发免费操作系统这个想法从4 月份就开始酝酿了，希望大家反馈一些对于minix 系统中喜欢那些特色不喜欢什么等信息，由于实际的和其它一些原因，新开发的系统刚开始与minix 很象（并且使用了minix 的文件系统）。并且已经成功地将bash(1.08 版)和gcc(1.40 版)移植到了新系统上，而且再过几个月就可以使用了。

最后，Linus 申明他开发的操作系统没有使用一行minix 的源代码；而且由于使用了386 的任务切换特性，所以该操作系统不好移植（没有可移植性），并且只能使用AT 硬盘。对于Linux 的移植性问题，Linus 当时并没有考虑。但是目前Linux 几乎可以运行在任何一种硬件体系结构上。

到了1991 年的10 月5 日，Linus 在comp.os.minix 新闻组上发布消息，正式向外宣布Linux 内核系统的诞生（Free minix-like kernel sources for 386-AT）。这段消息可以称为Linux 的诞生宣言，并且一直广为流传。因此10 月5 日对Linux 社区来说是一个特殊的日子，许多后来Linux 的新版本发布时都选择了这个日子。所以RedHat 公司选择这个日子发布它的新系统也不是偶然的。

\subsubsection{名称的来由}
\label{sec-1.1.2}

Linux 操作系统刚开始时并没有被称作Linux，Linus 给他的操作系统取名为FREAX，其英文含义是怪诞的、怪物、异想天开等意思。在他将新的操作系统上载到ftp，funet。fi服务器上时，管理员Ari Lemke很不喜欢这个名称。他认为既然是Linus 的操作系统就取其谐音Linux 作为该操作系统的目录吧，于是Linux 这个名称就开始流传下来。
　　
在Linus 的自传《Just for Fun》一书中，Linus 解释说："坦白地说，我从来没有想到过要用Linux 这个名称发布这个操作系统，因为这个名字有些太自负了。而我为最终发布版准备的是什么名字呢Freax。实际上，内核代码中某些早期的Makefile - 用于描述如何编译源代码的文件 - 文件中就已经包含有"Freax"这个名字了，大约存在了半年左右。但其实这也没什么关系，在当时还不需要一个名字，因为我还没有向任何人发布过内核代码。而Ari Lemke，他坚持要用自己的方式将内核代码放到ftp 站点上，并且非常不喜欢Freax 这个名字。他坚持要用现在这个名字(Linux)，我承认当时我并没有跟他多争论。但这都是他取的名字。所以我可以光明正大地说我并不自负，或者部分坦白地说我并没有本位主义思想。但我想好吧，这也是个好名字，而且以后为这事我总能说服别人，就象我现在做的这样。"-- Linus Torvalds《Just for fun》第84-88 页。

\subsubsection{基本思想}
\label{sec-1.1.3}

Linux的基本思想有两点：第一，一切都是文件；第二，每个软件都有确定的用途。其中第一条详细来讲就是系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。

\subsection{常见的Linux发行版}
\label{sec-1.2}

\subsubsection{Ubuntu}
\label{sec-1.2.1}

Ubuntu是一个南非的民族观念，着眼于人们之间的忠诚和联系。该词来自于祖鲁语和科萨语。Ubuntu（发音''oo-BOON-too''--“乌班图”）被视为非洲人的传统理念，也是建立新南非共和国的基本原则之一，与非洲复兴的理想密切相关。
Ubuntu 精神的大意是“人道待人”（对他人仁慈）。另一种翻译可以是：“天下共享的信念，连接起每个人”。

Ubuntu 的所有版本至少会提供18个月的安全和其它升级支持（Long-Term Support）。Ubuntu 6.06 LTS有点特别，它已是个准企业级版本，其桌面版本会提供3年支持，而服务器版本则将提供长达5年的支持。Ubuntu 6.06 LTS的开发周期比往常稍长，并专注于诸多领域，如：

质量保证

本地化

认证

所以，和以往版本相比，您可放心长期使用Ubuntu 6.06 LTS，由此该版本也被冠以“LTS”或“长期支持”（Long-Term Support）。

Ubuntu 的版本号是根据我们发布一个版本的日期而定。版本号由该次发布的年份和月份组成，并未反映其实际版本。我们的首次发布(Warty Warthog)是在2004年10月，因此该版本为4.10。重要的一个版本(Dapper Drake)是于2006年6月发布，因此版本号为6.06 LTS，其后是Ubuntu 8.04 LTS(Hardy Heron)，当前最新的LTS版本为Ubuntu 10.04 LTS(Lucid Lynx)。

7.10 . Gutsy Gibbon . 2007-10

7.04 ・ Feisty Fawn . 2007-4

6.10 ・ Edgy Eft . 2006-10

6.06 ・ Dapper Drake . 2006-6

5.10 ・ Breezy Badger . 2005-10

5.04 . Hoary Hedgehog . 2005-04



\subsubsection{Debian}
\label{sec-1.2.2}

Debian GNU/Linux 是最严谨，最开放和最自由的GNU/Linux发行套件，秉承Linux网络协作开发的完全黑客精神，是目前著名的Linux发行套件中唯一的非商业性版本。Debian的名称来源于其创始人Ian Murdock和他的妻子Debra二人的名字组合。

Debian 最早由Ian Murdock于1993年创建。可以算是迄今为止，最遵循GNU规范的Linux系统。Debian系统分为三个版本分支（branch）： stable, testing 和 unstable。截至2005年5月，这三个版本分支分别对应的具体版本为：Woody, Sarge 和 Sid。其中，unstable为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。testing的版本都经过 unstable中的测试，相对较为稳定，也支持了不少新技术（比如SMP等）。而Woody一般只用于服务器，上面的软件包大部分都比较过时，但是稳定 和安全性都非常的高。

Ubuntu 和 Debian是密切相关的，Ubuntu 是基于 Debian 的体系和基础之上建立的，只是拥有不同的社区和发布过程。
Debian 是“Ubuntu 建立的基石”。

作为一个自愿者组织，Debian 在历史上对基于时间或预告的发布做得不是很好，对时间的把握也很困难。Debian 的 Stable 版本在近年来更新极少而且漫长。更多的不成熟的非发布版本并未对个别更新较快的包提供安全修复，就集成在开发工作中。尽管这对大多数 Debian 用户来说并不重要，但这些缺点已经开始阻碍一些潜在的 Debian 用户。然而 Debian 拥有比其他发行版更好的架构，并允许大多数自由组合软件中的组件能被修复成符合您的需要。

Ubuntu 项目组希望能专注于这些内容中的一部分，并将更多的人吸引到 Debian 系统中。 由 Canonical 赞助，Ubuntu 项目基于 Debian，并试图专注于保持大多数用户愿意使用 Debian 这一方面。Ubuntu 提供一个基于 Debian 的系统，该系统保持一个快速的基于时间的发布，团队的理解，更多的是在考虑桌面界面。Ubuntu 带给用户的是配置 Debian 的安全修复、版本的关键 BUG 修复、可靠稳定的桌面界面和从不超过六个月的开源社区最新版本。

下一代 Debian 正式发行版的代号为 wheezy ― 发布时间尚未确定

Debian 6.0 (squeeze) ― 当前的稳定版

Debian GNU/Linux 5.0 (lenny) ― 被淘汰的稳定版

Debian GNU/Linux 4.0 (etch) ― 被淘汰的稳定版

Debian GNU/Linux 3.1 (sarge) ― 被淘汰的稳定版

Debian GNU/Linux 3.0 (woody) ― 被淘汰的稳定版

Debian GNU/Linux 2.2 (potato) ― 被淘汰的稳定版

Debian GNU/Linux 2.1 (slink) ― 被淘汰的稳定版

Debian GNU/Linux 2.0 (hamm) ― 被淘汰的稳定版

\subsubsection{Fedora Redhat Centos}
\label{sec-1.2.3}

Fedora 项目是由 Red Hat 赞助，由开源社区与 Red Hat 工程师合作开发的项目统称。Fedora 的目标，是推动自由和开源软件更快地进步。公开的论坛，开放的过程，快速的创新，精英和透明的管理，所有这些都为实现一个自由软件能提供的最好的操作系统和平台。

全世界的Linux用户最熟悉、最耳闻能详的发行版想必就是Red Hat了。Red Hat最早由Bob Young和Marc Ewing在1995年创建。而公司在最近才开始真正步入盈利时代，归功于收费的Red Hat Enterprise Linux（RHEL，Red Hat的企业版）。而正统的Red Hat版本早已停止技术支持，最后一版是Red Hat 9.0。于是，目前Red Hat分为两个系列：由Red Hat公司提供收费技术支持和更新的Red Hat Enterprise Linux，以及由社区开发的免费的Fedora Core。Fedora Core 1发布于2003年年末，而FC的定位便是桌面用户。FC提供了最新的软件包，同时，它的版本更新周期也非常短，仅六个月。

适用于服务器的版本是Red Hat Enterprise Linux，而由于这是个收费的操作系统。于是，国内外许多企业或空间商选择CentOS。CentOS可以算是RHEL的克隆版，但它最大的好处是免费！

\subsubsection{open SUSE}
\label{sec-1.2.4}

SUSE是德国最著名的Linux发行版，在全世界范围中也享有较高的声誉。SUSE自主开发的软件包管理系统YaST也大受好评。SUSE于2003年年末被Novell收购。

SUSE在收购之后的发布显得比较混乱，比如9.0版本是收费的，而10.0版本（也许由于各种压力）又免费发布。这使得一部分用户感到困惑，也转而使用其它发行版本。最近还跟微软扯到了一起。但是，瑕不掩瑜，SUSE仍然是一个非常专业、优秀的发行版。

openSUSE 项目是由Novell公司资助的全球性社区计划， 旨在推进 Linux 的广泛使用。这个计划提供免费的 openSUSE 操作系统。这里是一个由普通用户和开发者共同构成的社区，我们拥有一个共同的目标―创造世界上最好用的 Linux 发行版。openSUSE 是 Novell 公司发行的企业级 Linux 产品的系统基础。

openSUSE 项目是由 Novell 发起的开源社区计划。 旨在推进 Linux 的广泛使用。 openSUSE.org 提供了自由简单的方法来获得世界上最好用的 Linux 发行版，SUSE Linux。 openSUSE 项目为 Linux 开发者和爱好者提供了开始使用 Linux 所需要的一切。

《Novell 被收购相关新闻》\\
\label{sec-1.2.4.1}

Attachmate 集团宣布以22亿美元收购 Novell ，同时 Novell 宣布将部分知识产权以4亿5千万美元出售给 M\$ 组建的 CPTN Holdings 有限责任公司。

Attachmate 集团决定将 Novell 和 SuSe 分别合并至 Attachmate 和 NetIQ 部门运作。
而目前 M\$ 方面尚未对从 Novell 手中获得的知识产权做出任何评价，其中牵扯的 WordPrefect 及 Linux 专利问题依旧不明朗。同时也未透露 CPTN Holdings 公司中其他投资人的身份。

Attachmate 公开声明 Novell 所持有 UNIX 相关知识产权并未出售给 CPTN 。

\subsubsection{LFS}
\label{sec-1.2.5}
LFS──Linux from Scratch，就是一种从网上直接下载源码，从头编译LINUX的安装方式。它不是发行版，只是一个菜谱，告诉你到哪里去买菜(下载源码)，怎么把这些生东西( raw code) 作成符合自己口味的菜肴──个性化的linux，不单单是个性的桌面。

LFS 存在的一个重要原因是可以帮助人们学习 linux 系统的内部是如何工作的。构建一个 LFS 系统会帮助演示是什么使 linux运转，各种组件如何在一起互相依赖的工作。最好的事情之一，是这种学习的经历给予的是一种能力，能够定制满足您自己需要的 linux。

LFS 的一个关键的好处是它让用户对于系统有更多的控制，而不是依赖于某些人的 linux 实现。在 LFS 的世界里，你是坐在司机的位置，掌控系统的每一个细节，比如目录层次和启动脚本配置。你也能掌控程序在哪里，为何，以及怎样被安装。

LFS 的另一个好处是可以创建一个非常紧凑的 linux系统。当安装一个常规的发行版时，人们经常要被迫安装一些可能永远不会用到的程序。这些程序浪费宝贵的磁盘空间，或更糟的是占用CPU资源。要构建一个少于100兆(MB)的 LFS系统不是一件难事，这相比较目前大多数的发行版要小很多。这听起来是不是仍然占许多空间？我们中一些人的工作是创建一个非常小的嵌入式的 LFS系统。我们成功的构建了一个系统，在只运行 Apache服务器的情况下，大约占8MB磁盘空间。进一步的缩减能够减至5MB或更少。你用一个常规的分发版本试试？这也只是设计你自己的 linux所带来的好处之一。

我们可以拿 linux 发行版与快餐店出售的汉堡打比喻，您不能决定您应该吃什么。相反，LFS没有给您一个汉堡。而是给您一张制作汉堡的配方。用户可以查阅配方，减掉不想要的配料，增加你自己的配料以增强汉堡的口味。当你对配方满意的时候，开始去做准备。您可以采用确定的方式：或烤，或烘，或炸，或焙。

另外一个比方是把 LFS 与建筑房子比较。LFS 提供房子的框架蓝图，但是需要您去建筑它。LFS 包含了在这过程中调整计划的自由，定制满足用户的需要和参考。

用户定制的 linux 系统的另一个好处是安全性。通过从源码编译整个系统，您能够审查任何东西，打上所有的安全补丁，而不需要等待别人去编译好修补了安全漏洞的二进制包。除非是您发现并制作的补丁，否则您得不到任何的保证，新的二进制包是否正确编译或修正了问题。

\subsection{查看linux版本}
\label{sec-1.3}

\subsubsection{查看linux版本}
\label{sec-1.3.1}

lsb\_release -a

cat /etc/issue

cat /etc/redhat-release(只对Redhat Linux有效)

\subsubsection{查看内核版本}
\label{sec-1.3.2}

cat /proc/version

uname -a

\subsubsection{Linux 操作系统版本的变迁}
\label{sec-1.3.3}

0.00 (1991.2-4?) 两个进程分别显示AAA BBB

0.01 (1991.9?)第一个正式向外公布的Linux 内核版本。

0.02 (1991.10.5)该版本以及0.03 版是内部版本，目前已经无法找到。

0.03 (1991.10.5)

0.10 (1991.10)由Ted Ts'o 发布的Linux 内核版本。

0.11 (1991.12.8)基本可以正常运行的内核版本。

0.12 (1992.1.15)主要加入对数学协处理器的软件模拟程序。

0.95 (0.13) (1992.3.8) 开始加入虚拟文件系统思想的内核版本。

0.96 (1992.5.12)开始加入网络支持和虚拟文件系统VFS。

0.97 (1992.8.1)

0.98 (1992.9.29)

0.99 (1992.12.13)

1.0 (1994.3.14)

1.20 (1995.3.7)

2.0 (1996.2.9)

2.20 (1999.1.26)

2.40 (2001.1.4)

2.60 (2003.12.17)

\href{unix_a4.pdf}{《UNIX相关操作系统发行版历史》}

\subsection{在 bashshell 命令行模式下运行基本的 Linux 命令}
\label{sec-1.4}

\subsubsection{什么是shell}
\label{sec-1.4.1}

Linux系统的shell作为操作系统的外壳，为用户提供使用操作系统的接口。它是命令语言、命令解释程序及程序设计语言的统称。

shell是用户和Linux内核之间的接口程序，如果把Linux内核想象成一个球体的中心，shell就是围绕内核的外层。当从shell或其他程序向Linux传递命令时，内核会做出相应的反应。

shell是一个命令语言解释器，它拥有自己内建的shell命令集，shell也能被系统中其他应用程序所调用。用户在提示符下输入的命令都由shell先解释然后传给Linux核心。

有一些命令，比如改变工作目录命令cd，是包含在shell内部的。还有一些命令，例如拷贝命令cp和移动命令rm，是存在于文件系统中某个目录下的单独的程序。对用户而言，不必关心一个命令是建立在shell内部还是一个单独的程序。

shell首先检查命令是否是内部命令，若不是再检查是否是一个应用程序（这里的应用程序可以是Linux本身的实用程序，如ls和rm，也可以是购买的商业程序，如xv，或者是自由软件，如emacs）。然后shell在搜索路径里寻找这些应用程序（搜索路径就是一个能找到可执行程序的目录列表）。如果键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。如果能够成功找到命令，该内部命令或应用程序将被分解为系统调用并传给Linux内核。
　
shell的另一个重要特性是它自身就是一个解释型的程序设计语言，shell程序设计语言支持绝大多数在高级语言中能见到的程序元素，如函数、变量、数组和程序控制结构。shell编程语言简单易学，任何在提示符中能键入的命令都能放到一个可执行的shell程序中。

当普通用户成功登录，系统将执行一个称为shell的程序。正是shell进程提供了命令行提示符。作为默认值，对普通用户用“\$”作提示符，对超级用户（root）用“\#”作提示符。

一旦出现了shell提示符，就可以键入命令名称及命令所需要的参数。shell将执行这些命令。如果一条命令花费了很长的时间来运行，或者在屏幕上产生了大量的输出，可以从键盘上按ctrl+c发出中断信号来中断它（在正常结束之前，中止它的执行）。

当用户准备结束登录对话进程时，可以键入logout命令、exit命令或文件结束符（EOF）（按ctrl+d实现），结束登录。
\subsubsection{linux shell的历史及常见的shell}
\label{sec-1.4.2}

Linux中的shell有多种类型，其中最常用的几种是Bourne shell（sh）、C shell（csh）和Korn shell（ksh）。三种shell各有优缺点。
Linux，还包括了一些流行的shell如ash、zsh等。每个shell都有它的用途，有些shell是有专利的，有些能从Internet网上或其他来源获得。

\begin{itemize}

\item Bourne Shell\\
\label{sec-1.4.2.1}
Bourne shell是UNIX最初使用的shell，并且在每种UNIX上都可以使用。Bourne shell在shell编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。Linux操作系统缺省的shell是Bourne Again shell，它是Bourne shell的扩展，简称Bash，与Bourne shell完全向后兼容，并且在Bourne shell的基础上增加、增强了很多特性。Bash放在/bin/bash中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多C shell和Korn shell中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。

\begin{itemize}
\item 自动补齐\\
\label{sec-1.4.2.1.1}
<TAB> 键可以很方便地用于根据前几个字母，来查找匹配的文件或子目录。比如，ls /usr/bin/zip<TAB> 将列出所有'/usr/bin'下面，以字符串'zip'开头的文件或子目录。
\item 命令行的历史记录\\
\label{sec-1.4.2.1.2}
过按向上方向键，您可以向后遍历近来在该控制台下输入的命令。用向下方向键可以向前遍历。与 SHIFT 键连用的话，您还可以遍历以往在该控制台中的输出。您也可以编辑旧的命令，然后再运行。

按 <CTRL r> 后，shell 就进入''reverse-i(ncremental)-search''（向后增量搜索）模式。

通过光标和功能键（Home、End 等键），您可以浏览并编辑命令行，如果您需要，还可以用键盘的快捷方式来完成一般的编辑：

 <CTRL k>：删除从光标到行尾的部分

 <CTRL u>：删除从光标到行首的部分

 <ALT d>：删除从光标到当前单词结尾的部分

 <CTRL w>：删除从光标到当前单词开头的部分

 <CTRL a>：将光标移到行首

 <CTRL e>：将光标移到行尾

 <ALT a>：将光标移到当前单词头部

 <ALT e>：将光标移到当前单词尾部

 <CTRL y>：插入最近删除的单词

 <!\$>：重复前一个命令最后的参数。

\item 便捷功能\\
\label{sec-1.4.2.1.3}
由于 home 目录是每位用户的活动中心，许多 Unix 对此有特殊的快捷方式。'$\sim$'就是您的 home 目录的简写形式。

ll ：将执行'ls -l -k'（以长格式列出目录内容，包括一些文件属性，并以 KB 而不是 byte 为单位显示文件大小）

shell 的特殊字符:可以通过反斜线(back slash)来引用特殊字符，比如 ! 、\$ 、? 或空格：

ls  $\backslash$!*

或者用（单）引号：

ls '!'*


\item 输出重定向\\
\label{sec-1.4.2.1.4}
Unix 的理念是汇集许多小程序，每个东东都有特殊的专长。复杂的任务不是由大型软件完成，而是运用 shell 的机制，组合许多小程序共同完成。重定向就在其中发挥着重要的作用。

\begin{itemize}
\item 在多个命令间重定向\\
\label{sec-1.4.2.1.4.1}
这要通过管道(pipe)，由管道符号｜来标识。语法是：

command1 | command2 | command3 等等

\item 重定向至文件\\
\label{sec-1.4.2.1.4.2}
有时，您希望将命令的输出结果保存到文件中，或以文件内容作为命令的参数。这可以通过'>'和'<'来实现。

command > file

将 command 的输出保存到 file 中，这将覆盖 file 中的内容：

ls > dirlist

将当前目录的内容保存到'dirlist'文件。

\end{itemize} % ends low level

\item 命令的连续执行\\
\label{sec-1.4.2.1.5}
command1 \&\& command2：只有当 command1 正确运行完毕后，才执行 command2 。

\item 配置文件\\
\label{sec-1.4.2.1.6}
在您的 home 目录下，运行

ls .bash*

您将看到这些文件：

 .bash\_history ：记录了您以前输入的命令，

 .bash\_logout ：当您退出 shell 时，要执行的命令，

 .bash\_profile ：当您登入 shell 时，要执行的命令，

 .bashrc ：每次打开新的 shell 时，要执行的命令。
\end{itemize} % ends low level

\item TCSH\\
\label{sec-1.4.2.2}
TCSH shell不同于其他的shell,因为控制结构更符合程序设计语言的格式.例如
TCSH 的test条件的控制结构是表达式,而不是linux命令,得到的值是逻辑值true
或false,TCSH的表达式与C语言中的表达式基本相同.

\item pdksh\\
\label{sec-1.4.2.3}
Korn shell集合了C shell和Bourne shell的优点并且和Bourne shell完全兼容。Linux系统提供了pdksh（ksh的扩展），它支持任务控制，可以在命令行上挂起、后台执行、唤醒或终止程序。
\end{itemize} % ends low level


\subsection{了解 Linux 文件系统}
\label{sec-1.5}

\subsubsection{Linux 文件系统组件的体系结构}
\label{sec-1.5.1}

用户空间包含一些应用程序（例如，文件系统的使用者）和 GNU C 库（glibc），它们为文件系统调用（打开、读取、写和关闭）提供用户接口。系统调用接口的作用就像是交换器，它将系统调用从用户空间发送到内核空间中的适当端点。
VFS 是底层文件系统的主要接口。这个组件导出一组接口，然后将它们抽象到各个文件系统，各个文件系统的行为可能差异很大。有两个针对文件系统对象的缓存（inode 和 dentry）。它们缓存最近使用过的文件系统对象。

每个文件系统实现（比如 ext2、JFS 等等）导出一组通用接口，供 VFS 使用。缓冲区缓存会缓存文件系统和相关块设备之间的请求。例如，对底层设备驱动程序的读写请求会通过缓冲区缓存来传递。这就允许在其中缓存请求，减少访问物理设备的次数，加快访问速度。以最近使用（LRU）列表的形式管理缓冲区缓存。注意，可以使用 sync 命令将缓冲区缓存中的请求发送到存储媒体（迫使所有未写的数据发送到设备驱动程序，进而发送到存储设备）。
\subsubsection{文件系统的类型}
\label{sec-1.5.2}

\begin{itemize}

\item ext2 文件系统；\\
\label{sec-1.5.2.1}
ext2文件系统应该说是Linux正宗的文件系统，早期的Linux都是用ext2，但随着技术的发展，大多Linux的发行版本目前并不用这个文件系统了；比如Redhat和Fedora 大多都建议用ext3 ，ext3文件系统是由ext2发展而来的。对于Linux新手，我们还是建议您不要用ext2文件系统；ext2支持undelete（反删除），如果您误删除文件，有时是可以恢复的，但操作上比较麻烦

\item ext3 文件系统\\
\label{sec-1.5.2.2}
是由ext2文件系统发展而来,是一个用于Linux的日志文件系统,ext3支持大文件；但不支持反删除（undelete）操作

\item reiserfs 文件系统\\
\label{sec-1.5.2.3}
reiserfs 文件系统是一款优秀的文件系统，支持大文件，支持反删除（undelete）；reiserfs 反删除文件功能的过程中，几乎能恢复 90\%以上的数据，有时能恢复到100\%；操作反删除比较容易；reiserfs 支持大文件

\item Btrfs\\
\label{sec-1.5.2.4}
Btrfs就被人视作是下一代的存储技术，现有的Linux文件系统的竞争者和取代者。自从2.6.29进入内核主线以来，每一次内核小版本的发布都包括了Btrfs的改进。

Btrfs的基本特点是使用了copy on write (COW)，这意味着Btrfs在普通操作中不会直接覆盖数据，而是将元数据（metadata）和数据的新值写到别的地方，然后在文件系统中指向新的位置。 这就提供了强大的一致性和完整性保证。在海量存储上，这对于保持数据的可管理非常重要。

在COW之外，Btrfs还提供了快照和调整文件系统大小的功能。
\end{itemize} % ends low level
\subsection{用磁盘存取文件}
\label{sec-1.6}

\subsubsection{什么是块设备}
\label{sec-1.6.1}
块设备就是以块（比如磁盘扇区）为单位收发数据的设备，它们支持缓冲和随机访问（不必顺序读取块，而是可以在任何时候访问任何块）等特性。块设备包括硬盘、CD-ROM 和 RAM 盘。与块设备相对的是字符设备，字符设备没有可以进行物理寻址的媒体。字符设备包括串行端口和磁带设备，只能逐字符地读取这些设备中的数据。
\subsubsection{磁盘的分割}
\label{sec-1.6.2}
这是针对大容量的存储设备来说的，主要是指硬盘；对于大硬盘，我们要合理规划分区，所以要谈到硬盘的分割。硬盘的分割，Linux有fdisk、cfdisk和parted等，常用的还是fdisk 工具，Windows和dos常用的也有fdisk ，但和Linux中的使用方法不一样。硬盘的分割工具还有第三方程序，比如PQ

fdisk -l 查看硬盘及分区信息

Disk /dev/hda: 80.0 GB, 80026361856 bytes

255 heads, 63 sectors/track, 9729 cylinders

Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot      Start         End      Blocks   Id  System

/dev/hda1   *           1         765     6144831    7  HPFS/NTFS

/dev/hda2             766        2805    16386300    c  W95 FAT32 (LBA)

/dev/hda3            2806        9729    55617030    5  Extended

/dev/hda5            2806        3825     8193118+  83  Linux

/dev/hda6            3826        5100    10241406   83  Linux

/dev/hda7            5101        5198      787153+  82  Linux swap / Solaris

/dev/hda8            5199        6657    11719386   83  Linux

/dev/hda9            6658        7751     8787523+  83  Linux

/dev/hda10           7752        9729    15888253+  83  Linux

其中 heads 是磁盘面；sectors 是扇区；cylinders 是柱面；每个扇区大小是 512byte，也就是0.5K； 通过上面的例子，我们发现此硬盘有 255个磁盘面，有63个扇区，有9729个柱面；所以整个硬盘体积换算公式应该是：

磁面个数 x 扇区个数 x 每个扇区的大小512 x 柱面个数 = 硬盘体积 （单位bytes)

所以在本例中磁盘的大小应该计算如下： 255 x 63 x 512 x 9729 = 80023749120 bytes

提示：由于硬盘生产商和操作系统换算不太一样，硬盘厂家以10进位的办法来换算，而操作系统是以2进位制来换算，所以在换算成M或者G 时，不同的算法结果却不一样；所以我们的硬盘有时标出的是80G，在操作系统下看却少几M； 上面例子中，硬盘厂家算法 和 操作系统算数比较：

硬盘厂家： 80023749120 bytes = 80023749.120 K = 80023.749120 M （向大单位换算，每次除以1000）

操作系统： 80023749120 bytes = 78148192.5 K = 76316.594238281 M （向大单位换算，每次除以1024）

我们在查看分区大小的时候，可以用生产厂家提供的算法来简单推算分区的大小；把小数点向前移动六位就是以G表示的大小；比如 hda1 的大小约为 6.144831G ；

fdisk 的说明；

   a   toggle a bootable flag

   b   edit bsd disklabel

   c   toggle the dos compatibility flag

   d   delete a partition   注：这是删除一个分区的动作；

   l   list known partition types  注：l是列出分区类型，以供我们设置相应分区的类型；

   m   print this menu  注：m 是列出帮助信息；

   n   add a new partition 注：添加一个分区；

   o   create a new empty DOS partition table

   p   print the partition table 注：p列出分区表；

   q   quit without saving changes 注：不保存退出；

   s   create a new empty Sun disklabel

   t   change a partition's system id  注：t 改变分区类型；

   u   change display/entry units

   v   verify the partition table

   w   write table to disk and exit  注：把分区表写入硬盘并退出；

   x   extra functionality (experts only)  注：扩展应用，专家功能；

parted 功能不错的分区工具；在Fedora 4.0中有带，可以自己安装上；在此主题中，我们只说如何查看磁盘的分区情况；

调用方法简单，parted 默认是打开的设备是/dev/hda ，也可以自己指定；比如 parted /dev/hda 或/dev/sda 等；退出的方法是 quit

在partd 的操作界面上，用p就可以列出当前磁盘的分区情况，如果想要查看其它磁盘，可以用 select 功能。
\subsubsection{文件系统的创建}
\label{sec-1.6.3}

这个过程是存储设备建立文件系统的过程，一般也被称为格式化或初始化，通过一些初始化工具来进行。一般的情况下每个类型的操作系统都有这方面的工具，也有多功能的第三方工具，比如PQ。我的建议是如果您不太懂操作系统自带的工具，可以用第三方工具来切割硬盘，把硬盘分割成若干分区，然后再用操作系统自带的工作来初始化分区，也就是格式化分区。在Linux中有 mkfs系列工具；

用 mkfs.bfs mkfs.ext2 mkfs.jfs mkfs.msdos mkfs.vfatmkfs.cramfs mkfs.ext3 mkfs.minix mkfs.reiserfs mkfs.xfs 等命令来格式化分区。

\subsubsection{挂载（mount）}
\label{sec-1.6.4}
文件系统只有挂载才能使用，Unix类的操作系统如此，Windows也是一样；在Windows更直观一些，具体内部机制我们不太了解。但Unix类的操作系统是通过mount进行的，挂载文件系统时要有挂载点，比如我们在安装Linux的过程中，有时会提示我们分区，然后建立文件系统，接着是问你的挂载点是什么 ，我们大多选择的是/ 。我们在Linux系统的使用过程中，也会挂载其它的硬盘分区，也要选中挂载点，挂载点通常是一个空置的目录，最好是我们自建的空置目录；

\subsubsection{磁盘空间管理}
\label{sec-1.6.5}
系统软件和应用软件，都要以文件的形式存储在计算机的磁盘空间中。因此，应该随时监视磁盘空间的使用情况。Linux系统提供了一组有关磁盘空间管理的命令。
\begin{itemize}
\item df命令\\
\label{sec-1.6.5.1}
功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。

语法：df ［选项］

说明：df命令可显示所有文件系统对i节点和磁盘块的使用情况。

该命令各个选项的含义如下：

　　-a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统。

　　-k 以k字节为单位显示。

　　-i 显示i节点信息，而不是磁盘块。

　　-t 显示各指定类型的文件系统的磁盘空间使用情况。

　　-x 列出不是某一指定类型文件系统的磁盘空间使用情况（与t选项相反）。

　　-T 显示文件系统类型。

du -h 可以更人性化的显示分区大小。例如：

    yyg@ubuntu-exp:$\sim$\$ df -h

    Filesystem            Size  Used Avail Use% Mounted on

    /dev/sda6             954G   11G  895G   2% /

    none                  3.9G  360K  3.9G   1% /dev

    none                  3.9G     0  3.9G   0% /dev/shm

    none                  3.9G  308K  3.9G   1% /var/run

    none                  3.9G     0  3.9G   0% /var/lock

    none                  3.9G     0  3.9G   0% /lib/init/rw

/dev/sda1             461M   62M  376M  15% /boot

\item du命令\\
\label{sec-1.6.5.2}
du的英文原义为“disk usage”，含义为显示磁盘空间的使用情况。

功能：统计目录（或文件）所占磁盘空间的大小。

语法：du ［选项］ ［Names…］

说明：该命令逐级进入指定目录的每一个子目录并显示该目录占用文件系统数据块（1024字节）的情况。若没有给出Names，则对当前目录进行统计。

该命令的各个选项含义如下：

　　-s 对每个Names参数只给出占用的数据块总数。

　　-a 递归地显示指定目录中各文件及子孙目录中各文件占用的数据块数。若既不指定-s，也不指定-a，则只显示Names中的每一个目录及其中的各子目录所占的磁盘块数。

　　-b 以字节为单位列出磁盘空间使用情况（系统缺省以k字节为单位）。

　　-k 以1024字节为单位列出磁盘空间使用情况。

　　-c 最后再加上一个总计（系统缺省设置）。

　　-l 计算所有的文件大小，对硬链接文件，则计算多次。

　　-x 跳过在不同文件系统上的目录不予统计。
\end{itemize} % ends low level
\subsubsection{dd命令}
\label{sec-1.6.6}
功能：把指定的输入文件拷贝到指定的输出文件中，并且在拷贝过程中可以进行格式转换。可以用该命令实现DOS下的diskcopy命令的作用。先用dd命令把软盘上的数据写成硬盘的一个寄存文件，再把这个寄存文件写入第二张软盘上，完成diskcopy的功能。需要注意的是，应该将硬盘上的寄存文件用rm命令删除掉。系统默认使用标准输入文件和标准输出文件。

语法：dd ［选项］

　　if =输入文件（或设备名称）。

　　of =输出文件（或设备名称）。

　　ibs = bytes 一次读取bytes字节，即读入缓冲区的字节数。

　　skip = blocks 跳过读入缓冲区开头的ibs*blocks块。

　　obs = bytes 一次写入bytes字节，即写入缓冲区的字节数。

　　bs = bytes 同时设置读/写缓冲区的字节数（等于设置ibs和obs）。

　　cbs = byte 一次转换bytes字节。

　　count=blocks 只拷贝输入的blocks块。

　　conv = ASCII 把EBCDIC码转换为ASCIl码。

　　conv = ebcdic 把ASCIl码转换为EBCDIC码。

　　conv = ibm 把ASCIl码转换为alternate EBCDIC码。

　　conv = block 把变动位转换成固定字符。

　　conv = ublock 把固定位转换成变动位。

　　conv = ucase 把字母由小写转换为大写。

　　conv = lcase 把字母由大写转换为小写。

　　conv = notrunc 不截短输出文件。

　　conv = swab 交换每一对输入字节。

　　conv = noerror 出错时不停止处理。

　　conv = sync 把每个输入记录的大小都调到ibs的大小（用NUL填充）。
\subsection{了解和维护文件存取权限}
\label{sec-1.7}

\subsubsection{文件访问权限}
\label{sec-1.7.1}
文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。

有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。

每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。例如：

\$ ls -l file.xxx

-rw-r--r-- 1 root root 483997 Ju1 l5 17:3l file.xxx

横线代表空许可。r代表只读，w代表写，x代表可执行。注意这里共有10个位置。第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。

例如：

\begin{itemize}
\item rw- r-- r--
\end{itemize}
普通文件 文件主 组用户 其他用户

是文件file.xxx的访问权限，表示是一个普通文件；file.xxx的属主有读写权限；与file.xxx属主同组的用户只有读权限；其他用户也只有读权限。

\subsubsection{chmod 命令}
\label{sec-1.7.2}
chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。

该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。
\begin{itemize}

\item 文字设定法\\
\label{sec-1.7.2.1}
chmod ［who］ ［+ | - | =］ ［mode］ 文件名

命令中各选项的含义为：

操作对象who可是下述字母中的任一个或者它们的组合：

u 表示“用户（user）”，即文件或目录的所有者。

g 表示“同组（group）用户”，即与文件属主有相同组ID的所有用户。

o 表示“其他（others）用户”。

a 表示“所有（all）用户”。它是系统默认值。

操作符号可以是：

+ 添加某个权限。

- 取消某个权限。

= 赋予给定权限并取消其他所有权限（如果有的话）。

设置mode所表示的权限可用下述字母的任意组合：

r 可读。

w 可写。

x 可执行。

X 只有目标文件对某些用户是可执行的或该目标文件是目录时才追加x 属性。

s 在文件执行时把进程的属主或组ID置为该文件的文件属主。方式“u＋s”设置文件的用户ID位，“g＋s”设置组ID位。

t 保存程序的文本到交换设备上。

u 与文件属主拥有一样的权限。

g 与和文件属主同组的用户拥有一样的权限。

o 与其他用户拥有一样的权限。

文件名：以空格分开的要改变权限的文件列表，支持通配符。

在一个命令行中可给出多个权限方式，其间用逗号隔开。例如：chmod g+r，o+r example

使同组和其他用户对文件example 有读权限。

例1：\$ chmod a+x sort

即设定文件sort的属性为：

文件属主（u） 增加执行权限

与文件属主同组用户（g） 增加执行权限

其他用户（o） 增加执行权限

例2：\$ chmod ug+w，o-x text

即设定文件text的属性为：

文件属主（u） 增加写权限

与文件属主同组用户（g） 增加写权限

其他用户（o） 删除执行权限

例3：\$ chmod u+s a.out

假设执行chmod后a.out的权限为（可以用ls C l a.out命令来看）：

Crws--x--x 1 user1 users 7192 Nov 4 14:22 a.out

并且这个执行文件要用到一个文本文件shiyan1.c，其文件存取权限为“Crw-------”，即该文件只有其属主user1具有读写权限。

当其他用户执行a.out这个程序时，他的身份因这个程序暂时变成user1（由于chmod命令中使用了s选项），所以他就能够读取shiyan1.c这个文件（虽然这个文件被设定为其他人不具备任何权限），这就是s的功能。

因此，在整个系统中特别是root本身，最好不要过多的设置这种类型的文件（除非必要）这样可以保障系统的安全，避免因为某些程序的bug而使系统遭到入侵。

\item 数字设定法\\
\label{sec-1.7.2.2}
我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。

例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。

数字设定法的一般形式为：

chmod ［mode］ 文件名

例1： \$ chmod 644 mm.txt

\$ ls Cl

即设定文件mm.txt的属性为：

-rw-r--r-- 1 inin users 1155 Nov 5 11:22 mm.txt

文件属主（u）inin 拥有读、写权限

与文件属主同组人用户（g） 拥有读权限

其他人（o） 拥有读权限

例2： \$ chmod 750 wch.txt

\$ ls Cl

-rwxr-x--- 1 inin users 44137 Nov 12 9:22 wchtxt

即设定wchtxt这个文件的属性为：

文件主本人（u）inin 可读/可写/可执行权

与文件主同组人（g） 可读/可执行权

其他人（o） 没有任何权限

\end{itemize} % ends low level
\subsubsection{chgrp命令}
\label{sec-1.7.3}
功能：改变文件或目录所属的组。

语法：chgrp ［选项］ group filename?

该命令改变指定指定文件所属的用户组。其中group可以是用户组ID，也可以是/etc/group文件中用户组的组名。文件名是以空格分开的要改变属组的文件列表，支持通配符。如果用户不是该文件的属主或超级用户，则不能改变该文件的组。

该命令的各选项含义为：

\begin{itemize}
\item R 递归式地改变指定目录及其下的所有子目录和文件的属组。
\end{itemize}
例1：\$ chgrp - R book /opt/local /book

改变/opt/local /book/及其子目录下的所有文件的属组为book。

\subsubsection{chown 命令}
\label{sec-1.7.4}
功能：更改某个文件或目录的属主和属组。这个命令也很常用。例如root用户把自己的一个文件拷贝给用户xu，为了让用户xu能够存取这个文件，root用户应该把这个文件的属主设为xu，否则，用户xu无法存取这个文件。

语法：chown ［选项］ 用户或组 文件

说明：chown将指定文件的拥有者改为指定的用户或组。用户可以是用户名或用户ID。组可以是组名或组ID。文件是以空格分开的要改变权限的文件列表，支持通配符。

该命令的各选项含义如下：

\begin{itemize}
\item R 递归式地改变指定目录及其下的所有子目录和文件的拥有者。
\item v 显示chown命令所做的工作。
\end{itemize}
例1：把文件shiyan.c的所有者改为wang。

\$ chown wang shiyan.c

例2：把目录/his及其下的所有文件和子目录的属主改成wang，属组改成users。

\$ chown - R wang.users /his

\subsection{完成普通的文件维护工作}
\label{sec-1.8}

\subsubsection{显示文件内容命令}
\label{sec-1.8.1}


用户需要查看一个文件的内容时，可以根据显示要求的不同选用以下的命令。

\begin{itemize}

\item cat命令\\
\label{sec-1.8.1.1}
功能1：在标准输出上显示文件。

语法：cat ［ - 选项 ］ 文件

说明：该命令功能之一是用来显示文件。它依次读取其后所指文件的内容并将其输出到标准输出。

\item more命令\\
\label{sec-1.8.1.2}
功能：在终端屏幕按屏显示文本文件。

语法： more ［ - 选项 ］ 文件

说明： 该命令一次显示一屏文本，显示满之后，停下来，并在终端底部打印出- - More- - ，系统还将同时显示出已显示文本占全部文本的百分比，若要继续显示，按回车或空格键即可。

\item less命令\\
\label{sec-1.8.1.3}
less命令的功能几乎和more命令一样，也是用来按页显示文件，不同之处在于less命令在显示文件时允许用户既可以向前又可以向后翻阅文件。

\item head命令\\
\label{sec-1.8.1.4}
如果用户希望查看一个文件究竟保存的是什么内容，可以只查看文件的头几行，而不必浏览整个文件。用head命令只显示文件或标准输入的头几行。

语法：head ［ -n ］ 文件

功能：显示指定文件的前若干行。

说明：该命令显示每个指定文件的前面n行。如果没有给出n值，缺省设置为10。如果没有指定文件，head就从标准输入读取。例如显示文件example.c的前3行。

\item tail命令\\
\label{sec-1.8.1.5}
同样，如果用户想查看文件的尾部，可以使用tail命令。

语法： tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] 文件

说明：tail 命令从指定点开始将 File 参数指定的文件写到标准输出。如果没有指定文件，则会使用标准输入。 Number 变量指定将多少单元写入标准输出。 Number 变量的值可以是正的或负的整数。如果值的前面有 +（加号），从文件开头指定的单元数开始将文件写到标准输出。如果值的前面有 -（减号），则从文件末尾指定的单元数开始将文件写到标准输出。如果值前面没有 +（加号）或 -（减号），那么从文件末尾指定的单元号开始读取文件。

tail命令中各个选项的含义为：

-b Number 从 Number 变量表示的 512 字节块位置开始读取指定文件。

-c Number 从 Number 变量表示的字节位置开始读取指定文件。

-f 如果输入文件是常规文件或如果 File 参数指定 FIFO（先进先出），
   那么 tail 命令不会在复制了输入文件的最后的指定单元后终止，而是继续
   从输入文件读取和复制额外的单元（当这些单元可用时）。如果没有指定 File 参数，
   并且标准输入是管道，则会忽略 -f 标志。tail -f 命令可用于监视另一个进程正在
   写入的文件的增长。

-k Number 从 Number 变量表示的 1KB 块位置开始读取指定文件。

-m Number 从 Number 变量表示的多字节字符位置开始读取指定文件。使用该标志提供在
   单字节和双字节字符代码集环境中的一致结果。

-n Number 从首行或末行位置来读取指定文件，位置由 Number 变量的符号（+ 或 - 或无）
   表示，并通过行号 Number 进行位移。

-r 从文件末尾以逆序方式显示输出。-r 标志的缺省值是以逆序方式显示整个文件。
   如果文件大于 20,480 字节，那么-r标志只显示最后的 20,480 字节。 -r 标志只有
   与 -n 标志一起时才有效。否则，就会将其忽略。

\end{itemize} % ends low level
\subsubsection{目录的创建与删除命令　}
\label{sec-1.8.2}

\begin{itemize}
\item mkdir命令\\
\label{sec-1.8.2.1}
功能：创建一个目录（类似DOS下的md命令）。

语法：mkdir ［选项］ dirname

说明：该命令创建由dirname命名的目录。要求创建目录的用户在当前目录中（dirname的父目录中）具有写权限，并且dirname不能是当前目录中已有的目录或文件名称。

命令中各选项的含义为：

-m 对新建目录设置存取权限。也可以用chmod命令设置。

-p 可以是一个路径名称。此时若路径中的某些目录尚不存在， 加上此选项后，系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录。

例如：在当前目录中建立inin 和inin下的/mail目录，也就是连续建两个目录。

\$ mkdir - p - m 700 ./inin/mail/

该命令的执行结果是在当前目录中创建嵌套的目录层次inin /mail，权限设置为只有文件主有读、写和执行权限。

\item rmdir 命令\\
\label{sec-1.8.2.2}
功能：删除空目录。

语法：rmdir ［选项］ dirname

说明：dirname表示目录名。该命令从一个目录中删除一个或多个子目录项。需要特别注意的是，一个目录被删除之前必须是空的。（注意，rm - r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。

命令中各选项的含义为：

 -p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。

例如：

\$ rmdir - p /usr/xu/txt

将/usr/xu/txt目录删除。

改变工作目录、显示目录内容命令

\item cd 命令\\
\label{sec-1.8.2.3}
功能：改变工作目录。

语法：cd ［directory］

说明：该命令将当前目录改变至directory所指定的目录。若没有指定directory，则回到用户的主目录。为了改变到指定目录，用户必须拥有对指定目录的执行和读权限。

该命令可以使用通配符（通配符含义请参见第十章）。

例如：假设用户当前目录是：/home/xu，现需要更换到/home/xu/pro目录中，

\$ cd pro

此时，用户可以执行pwd命令来显示工作目录。

\$ pwd

/home/xu/pro

\item pwd 命令\\
\label{sec-1.8.2.4}
在Linux层次目录结构中，用户可以在被授权的任意目录下利用mkdir命令创建新目录，也可以利用cd命令从一个目录转换到另一个目录。然而，没有提示符来告知用户目前处于哪一个目录中。要想知道当前所处的目录，可以使用pwd命令，该命令显示整个路径名。

语法：pwd

说明：此命令显示出当前工作目录的绝对路径。

例：\$ pwd

/home/xu

显示的路径名为/home/xu，每个目录名都用“/”隔开，根目录以开头的“/”表示。

\item ls 命令\\
\label{sec-1.8.2.5}
ls是英文单词list的简写，其功能为列出目录的内容。这是用户最常用的一个命令之一，因为用户需要不时地查看某个目录的内容。该命令类似于DOS下的dir命令。

语法：ls ［选项］ ［目录或是文件］

对于每个目录，该命令将列出其中的所有子目录与文件。对于每个文件，ls将输出其文件名以及所要求的其他信息。默认情况下，输出条目按字母顺序排序。当未给出目录名或是文件名时，就显示当前目录的信息。

命令中各选项的含义如下：

\begin{itemize}
\item a 显示指定目录下所有子目录与文件，包括隐藏文件。
\item A 显示指定目录下所有子目录与文件，包括隐藏文件。但不列出“.”和“..”。
\item b 对文件名中的不可显示字符用八进制逃逸字符显示。
\item c 按文件的修改时间排序。
\item C 分成多列显示各项。
\item d 如果参数是目录，只显示其名称而不显示其下的各文件。往往与l选项一起使用，以得到目录的详细信息。
\item f 不排序。该选项将使lts选项失效，并使aU选项有效。
\item F 在目录名后面标记“/”，可执行文件后面标记“*”，符号链接后面标记“@”，管道（或FIFO）后面标记“|”，socket文件后面标记“=”。
\item i 在输出的第一列显示文件的i节点号。
\item l 以长格式来显示文件的详细信息。这个选项最常用。每行列出的信息依次是：
\end{itemize}
文件类型与权限 链接数 文件属主 文件属组 文件大小 建立或最近修改的时间 名字

对于符号链接文件，显示的文件名之后有“―〉”和引用文件路径名。

对于设备文件，其“文件大小”字段显示主、次设备号，而不是文件大小。目录中的总块数显示在长格式列表的开头，其中包含间接块。

\begin{itemize}
\item L 若指定的名称为一个符号链接文件，则显示链接所指向的文件。
\item m 输出按字符流格式，文件跨页显示，以逗号分开。
\item n 输出格式与l选项相同，只不过在输出中文件属主和属组是用相应的UID号和GID号来表示，而不是实际的名称。
\item o 与l选项相同，只是不显示拥有者信息。
\item p 在目录后面加一个“/”。
\item q 将文件名中的不可显示字符用“?”代替。
\item r 按字母逆序或最早优先的顺序显示输出结果。
\item R 递归式地显示指定目录的各个子目录中的文件。
\item s 给出每个目录项所用的块数，包括间接块。
\item t 显示时按修改时间（最近优先）而不是按名字排序。若文件修改时间相同，则按字典顺序。修改时间取决于是否使用了c或u选顶。缺省的时间标记是最后一次修改时间。
\item u 显示时按文件上次存取的时间（最近优先）而不是按名字排序。即将-t的时间标记修改为最后一次访问的时间。
\item x 按行显示出各排序项的信息。
\end{itemize}
用ls - l命令显示的信息中，开头是由10个字符构成的字符串，其中第一个字符表示文件类型，它可以是下述类型之一：

\begin{itemize}
\item 普通文件
\end{itemize}
d 目录

l 符号链接

b 块设备文件

c 字符设备文件

后面的9个字符表示文件的访问权限，分为3组，每组3位。第一组表示文件属主的权限，第二组表示同组用户的权限，第三组表示其他用户的权限。每一组的三个字符分别表示对文件的读、写和执行权限。

各权限如下所示：

r 读

w 写

x 执行。对于目录，表示进入权限。

s 当文件被执行时，把该文件的UID或GID赋予执行进程的UID（用户ID）或GID（组ID）。

t 设置标志位（留在内存，不被换出）。如果该文件是目录，在该目录中的文件只能被超级用户、目录拥有者或文件属主删除。如果它是可执行文件，在该文件执行后，指向其正文段的指针仍留在内存。这样再次执行它时，系统就能更快地装入该文件。

\begin{itemize}
\item 没有设置权限。
\end{itemize}
例1：列出当前目录的内容。

\$ ls -F

bin/ lib/ var/

etc/ tmp/ index. html

例2：列出某个目录的内容。

\$ ls CF /home/xu

Mai1/ map1e/ mm/ ptr/ telnetd*

fd/ mbox mount sobsrc. tgz tmp/

例3：列出某个目录下所有的文件（包括隐藏文件）。

\$ 1s -aF /home/xu

./ . .e1m/ .netscape/ map1e ptr/

../ .fvwin2rc95 .term/ mbox sobsrc. tgz

.Xauthority .kermrc Mai1/ mm/ te1netd*

.bash-history .ncftp/ fd/ mount tmp/

例4：用长格式列出某个目录下所有的文件（包括隐藏文件）。

\$ 1s -laF /home/xu

total 584

drwxr-xr-x l2 root root 1024 Nov 02 22:07 ./

drwxr-xr-x 15 bbs bbs 1024 Jul 29 07:08 ../

-rw-r--r-- 1 yu users 4343 Ju1 29 22:20 .bash-history

drwx------ 2 yu users 1024 May 17 06:36 .e1m/

--rw------ 1 root root 4628 Jun 2 1l:34 mbox

lrwxrwxrwx 1 root root l4 Ju1 29 03:08 mount->/mnt

drwxrwxr-x 4 root root 1024 Ju1 23 03:43 ptr/

-rw--r--r- 1 root root 483997 Ju1 l5 17:3l sobsrc. tgz

-rwxr-xr-x l root users 60177 Jun 8 01:29 telnetd*

drwxr-xr-x 2 root root 1024 Mar 6 22:32 tmp/

例5：用长格式列出某个目录下所有的文件包括隐藏文件和它们的i节点号。并把文件属主和属组以UID号和GID号的形式显示。

\$ 1s -1ainF /home/xu

tota1 584

399672 drwxr-xr-x l2 0 0 l024 Nov 30 22:07 ./

333907 drwxr-xr-x 15 9999 99 l024 　Ju1 29 07:08 ../

39980l -rw------- l 0 0 0 Jun 2 2:09 .Xauthority

399679 -rw-r--r-- 1 505 l00 4343 Jul 29 22:20 .bash-hist0ry

30l763 drwxr----- 2 505 100 l024 　May 17 06:36 .e1m/
\end{itemize} % ends low level
\subsubsection{文件的复制、删除和移动命令}
\label{sec-1.8.3}
\begin{itemize}
\item  cp命令\\
\label{sec-1.8.3.1}
该命令的功能是将给出的文件或目录拷贝到另一文件或目录中，就如同DOS下的copy命令一样，功能非常强大。

语法： cp ［选项］ 源文件或目录 目标文件或目录

说明：该命令把指定的源文件复制到目标文件或把多个源文件复制到目标目录中。

该命令的各选项含义如下：

　　- a 该选项通常在拷贝目录时使用。它保留链接、文件属性，并递归地拷贝目录，其作用等于dpR选项的组合。

　　- d 拷贝时保留链接。

　　- f 删除已经存在的目标文件而不提示。

　　- i 和f选项相反，在覆盖目标文件之前将给出提示要求用户确认。回答y时目标文件将被覆盖，是交互式拷贝。

　　- p 此时cp除复制源文件的内容外，还将把其修改时间和访问权限也复制到新文件中。

　　- r 若给出的源文件是一目录文件，此时cp将递归复制该目录下所有的子目录和文件。此时目标文件必须为一个目录名。

　　- l 不作拷贝，只是链接文件。

需要说明的是，为防止用户在不经意的情况下用cp命令破坏另一个文件，如用户指定的目标文件名是一个已存在的文件名，用cp命令拷贝文件后，这个文件就会被新拷贝的源文件覆盖，因此，建议用户在使用cp命令拷贝文件时，最好使用i选项。

\$ cp - i exam1.c /usr/wang/shiyan1.c

该命令将文件exam1.c拷贝到/usr/wang 这个目录下，并改名为 shiyan1.c。若不希望重新命名，可以使用下面的命令：

\$ cp exam1.c \emph{usr} wang/

\$ cp - r \emph{usr/xu} \emph{usr/liu}

将/usr/xu目录中的所有文件及其子目录拷贝到目录/usr/liu中。

\item mv命令\\
\label{sec-1.8.3.2}
用户可以使用mv命令来为文件或目录改名或将文件由一个目录移入另一个目录中。该命令如同DOS下的ren和move的组合。

语法：mv ［选项］ 源文件或目录 目标文件或目录

说明：视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。

命令中各选项的含义为：

　　- I 交互方式操作。如果mv操作将导致对已存在的目标文件的覆盖，此时系统询问是否重写，要求用户回答y或n，这样可以避免误覆盖文件。

　　- f 禁止交互操作。在mv操作要覆盖某已有的目标文件时不给任何指示，指定此选项后，i选项将不再起作用。

　　如果所给目标文件（不是目录）已存在，此时该文件的内容将被新文件覆盖。为防止用户在不经意的情况下用mv命令破坏另一个文件，建议用户在使用mv命令移动文件时，最好使用i选项。

　　需要注意的是，mv与cp的结果不同。mv好象文件“搬家”，文件个数并末增加，而cp对文件进行复制，文件个数增加了。

例1：将/usr/xu中的所有文件移到当前目录（用“.”表示）中：

\$ mv \emph{usr/xu} * .

例2：将文件wch.txt重命名为wjz.doc

\$ mv wch.txt wjz.doc

\item rm命令\\
\label{sec-1.8.3.3}
在linux中创建文件很容易，系统中随时会有文件变得过时且毫无用处。用户可以用rm命令将其删除。该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。

rm命令的一般形式为：

　　rm ［选项］ 文件…

　　如果没有使用- r选项，则rm不会删除目录。

　　该命令的各选项含义如下：

　　- f 忽略不存在的文件，从不给出提示。

　　- r 指示rm将参数中列出的全部目录和子目录均递归地删除。

　　- i 进行交互式删除。

使用rm命令要格外小心。因为一旦一个文件被删除，它是不能被恢复的。例如，用户在输入cp，mv或其他命令时，不小心误输入了rm命令，当用户按了回车键并认识到自己的错误时，已经太晚了，文件已经没有了。为了防止此种情况的发生，可以使用rm命令中的 i选项来确认要删除的每个文件。如果用户输入y，文件将被删除。如果输入任何其他东西，文件将被保留。在下一个例子中，用户要删除文件test和example。然后会被要求对每个文件进行确认。用户最终决定删除example文件，保留test文件。

　　\$ rm - ii test example

　　Remove test ?n

　　Remove example ?y

\end{itemize} % ends low level
\subsubsection{文件查找命令find}
\label{sec-1.8.4}
功能：在目录结构中搜索文件，并执行指定的操作。此命令提供了相当多的查找条件，功能很强大。

语法：find 起始目录 寻找条件 操作

说明：find命令从指定的起始目录开始，递归地搜索其各个子目录，查找满足寻找条件的文件并对之采取相关的操作。

该命令提供的寻找条件可以是一个用逻辑运算符not、and、or组成的复合条件。逻辑运算符and、or、not的含义为：

（1）and：逻辑与，在命令中用“-a”表示，是系统缺省的选项，表示只有当所给的条件都满足时，寻找条件才算满足。例如：

\$ find Cname ’tmp’ Cxtype c -user ’inin’

该命令寻找三个给定条件都满足的所有文件。

（2）or：逻辑或，在命令中用“-o”表示。该运算符表示只要所给的条件中有一个满足时，寻找条件就算满足。例如：

\$ find Cname ’tmp’ Co Cname ’mina*’
　
该命令查询文件名为’tmp’或是匹配’mina*’的所有文件。

（3）not：逻辑非，在命令中用“！”表示。该运算符表示查找不满足所给条件的文件。例如：

\$ find ! Cname ’tmp’

该命令查询文件名不是’tmp’的所有文件。

需要说明的是：当使用很多的逻辑选项时，可以用括号把这些选项括起来。为了避免Shell本身对括号引起误解，在话号前需要加转义字符“”来去除括号的意义。

例：\$ find （Cname ’tmp’ Cxtype c -user ’inin’ ）

寻找条件有以下选项：

首先，下列各个选项中的n值可以有三种输入方式，假设n为20，则：

　　+20 表示20以后（21，22，23等）

　　-20 表示20以前（19，18，17等）

　　20 表示正好是20

1. 以名称和文件属性查找。

　　- name ’字串’ 查找文件名匹配所给字串的所有文件，字串内可用通配符*、?、［ ］。

　　- lname ’字串’ 查找文件名匹配所给字串的所有符号链接文件，字串内可用通配符*、?、［ ］。

　　-gid n 查找属于ID号为n的用户组的所有文件。

　　-uid n 查找属于ID号为n的用户的所有文件。

　　-group ’字串’ 查找属于用户组名为所给字串的所有的文件。

　　-user ’字串’ 查找属于用户名为所给字串的所有的文件。

　　-empty 查找大小为0的目录或文件。

　　-path ’字串’ 查找路径名匹配所给字串的所有文件，字串内可用通配符*、?、［ ］。

　　-perm 权限 查找具有指定权限的文件和目录，权限的表示可以如711，644。

　　-size n［bckw］ 查找指定文件大小的文件，n后面的字符表示单位，缺省为b，代表512字节的块。

　　-type x 查找类型为x的文件，x为下列字符之一：

　　b 块设备文件

　　c 字符设备文件

　　d 目录文件

　　p 命名管道（FIFO）

　　f 普通文件

　　l 符号链接文件（symbolic links）

　　s socket文件

　　-xtype x 与-type基本相同，但只查找符号链接文件。

2. 以时间为条件查找

　　- amin n 查找n分钟以前被访问过的所有文件。

　　- atime n 查找n天以前被访问过的所有文件。

　　- cmin n 查找n分钟以前文件状态被修改过的所有文件。

　　- ctime n 查找n天以前文件状态被修改过的所有文件。

　　- mmin n 查找n分钟以前文件内容被修改过的所有文件。

　　- mtime n 查找n天以前文件内容被修改过的所有文件。

3. 可执行的操作

　　- exec 命令名称 \{\} 对符合条件的文件执行所给的Linux 命令，而不询问用户是否需要执行该命令。\{\}表示命令的参数即为所找到的文件；命令的末尾必须以“ ；”结束。

　　- ok 命令名称 \{ \} 对符合条件的文件执行所给的Linux 命令，与exec不同的是，它会询问用户是否需要执行该命令。

　　- ls 详细列出所找到的所有文件。

　　- fprintf 文件名 将找到的文件名写入指定文件。

　　- print 在标准输出设备上显示查找出的文件名。

　　- printf 格式 格式的写法请参考有关C语言的书。

例1：查找当前目录中所有以main开头的文件，并显示这些文件的内容。

\$ find . - name ‘main*’ - exec more \{\} ;

例2：删除当前目录下所有一周之内没有被访问过的a .out或*.o文件。

\$ find . （- name a.out - o - name ‘*.o’）

> - atime +7 - exec rm \{\} ;

说明如下：

命令中的“.”表示当前目录，此时find将从当前目录开始，逐个在其子目录中查找满足后面指定条件的文件。（和）表示括号（），其中的“”称为转义符。之所以这样写是由于对Shell而言，（和）另有不同的含义，而不是这里的用于组合条件的用途。“- name a.out”是指要查找名为a.out的文件；“- name ‘*.o’”是指要查找所有名字以 .o结尾的文件。这两个- name之间的- o表示逻辑或（or），即查找名字为a.out或名字以 .o结尾的文件，find在当前目录及其子目录下找到这佯的文件之后，再进行判断，看其最后访问时间是否在7天以前（条件－atime +7），若是，则对该文件执行命令rm（- exec rm\{ \};）。其中\{ \}代表当前查到的符合条件的文件名，；则是语法所要求的。上述命令中第一行的最后一个是续行符。当命令太长而在一行写不下时，可输入一个，之后系统将显示一个>，指示用户继续输入命令。
\subsubsection{ln命令}
\label{sec-1.8.5}

该命令在文件之间创建链接。这种操作实际上是给系统中已有的某个文件指定另外一个可用于访问它的名称。对于这个新的文件名，我们可以为之指定不同的访问权限，以控制对信息的共享和安全性的问题。

如果链接指向目录，用户就可以利用该链接直接进入被链接的目录而不用打一大堆的路径名。而且，即使我们删除这个链接，也不会破坏原来的目录。

语法：ln ［选项］ 目标 ［链接名］

　　　ln ［选项］ 目标 目录

链接有两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。

在硬链接的情况下，参数中的“目标”被链接至［链接名］。如果［链接名］是一个目录名，系统将在该目录之下建立一个或多个与“目标”同名的链接文件，链接文件和被链接文件的内容完全相同。如果［链接名］为一个文件，用户将被告知该文件已存在且不进行链接。如果指定了多个“目标”参数，那么最后一个参数必须为目录。

如果给ln命令加上-s选项，则建立符号链接。如果［链接名］已经存在但不是目录，将不做链接。［链接名］可以是任何一个文件名（可包含路径），也可以是一个目录，并且允许它与“目标”不在同一个文件系统中。如果［链接名］是一个已经存在的目录，系统将在该目录下建立一个或多个与“目标”同名的文件，此新建的文件实际上是指向原“目标”的符号链接文件。

在目标名称已存在的情况下，可以添加参数 -f 强制建立链接

例：\$ ln -fs lunch /home/xu

用户为当前目录下的文件lunch创建了一个符号链接/home/xu。

\subsubsection{备份与压缩命令}
\label{sec-1.8.6}

\begin{itemize}

\item tar\\
\label{sec-1.8.6.1}

tar可以为文件和目录创建档案。利用tar，用户可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案，如软盘。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。Linux上的tar是GNU版本的。

　　语法：tar ［主选项+辅选项］ 文件或者目录


　　c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。

　　r 把要存档的文件追加到档案文件的未尾。例如用户已经作好备份文件，又发现还有一个目录或是一些文件忘记备份了，这时可以使用该选项，将忘记的目录或文件追加到备份文件中。

　　t 列出档案文件的内容，查看已经备份了哪些文件。

　　u 更新文件。就是说，用新增的文件取代原备份文件，如果在备份文件中找不到要更新的文件，则把它追加到备份文件的最后。

　　x 从档案文件中释放文件。

　　辅助选项：

　　b 该选项是为磁带机设定的。其后跟一数字，用来说明区块的大小，系统预设值为20（20*512 bytes）。

　　f 使用档案文件或设备，这个选项通常是必选的。

　　k 保存已经存在的文件。例如我们把某个文件还原，在还原的过程中，遇到相同的文件，不会进行覆盖。

　　m 在还原文件时，把所有文件的修改时间设定为现在。

　　M 创建多卷的档案文件，以便在几个磁盘中存放。

　　v 详细报告tar处理的文件信息。如无此选项，tar不报告文件信息。

　　w 每一步都要求确认。

　　z 用gzip来压缩/解压缩文件，加上该选项后可以将档案文件进行压缩，但还原时也一定要使用该选项进行解压缩。

例1：把/home目录下包括它的子目录全部做备份文件，备份文件名为usr.tar。

　　\$ tar cvf usr.tar /home

　　例2：把/home目录下包括它的子目录全部做备份文件，并进行压缩，备份文件名为usr.tar.gz 。

　　\$ tar czvf usr.tar.gz /home

　　例3：把usr.tar.gz这个备份文件还原并解压缩。

　　\$ tar xzvf usr.tar.gz


\item gzip\\
\label{sec-1.8.6.2}

gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。

　　语法：gzip ［选项］ 压缩（解压缩）的文件名

　　各选项的含义：

　　-c 将输出写到标准输出上，并保留原有文件。

　　-d 将压缩文件解压。

　　-l 对每个压缩文件，显示下列字段：

　　压缩文件的大小

　　未压缩文件的大小

　　压缩比

　　未压缩文件的名字

　　-r 递归式地查找指定目录并压缩其中的所有文件或者是解压缩。

　　-t 测试，检查压缩文件是否完整。

　　-v 对每一个压缩和解压的文件，显示文件名和压缩比。

　　-num 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6。

假设一个目录/home下有文件mm.txt、sort.txt、xx.com。

　　例1：把/home目录下的每个文件压缩成.gz文件。

　　\$ cd /home

　　\$ gzip *

　　\$ ls

　　m.txt.gz sort.txt.gz xx.com.gz

　　例2：把例1中每个压缩的文件解压，并列出详细的信息。

　　\$ gzip -dv *

　　mm.txt.gz 43.1\%-----replaced with mm.txt

　　sort.txt.gz 43.1\%-----replaced with sort.txt

　　xx.com.gz 43.1\%-----replaced with xx.com

　　\$ ls

　　mm.txt sort.txt xx.com


　　例3：详细显示例1中每个压缩的文件的信息，并不解压。

　　\$ gzip -l *

　　compressed uncompr. ratio uncompressed$_{\mathrm{name}}$

　　277 445 43.1\% mm.txt

　　278 445 43.1\% sort.txt

　　277 445 43.1\% xx.com

　　\$ ls

　　mm.txt.gz sort.txt.gz xx.com.gz

　　例4：压缩一个tar备份文件，如usr.tar，此时压缩文件的扩展名为.tar.gz

　　\$ gzip usr.tar

　　\$ ls

　　usr.tar.gz


\item unzip\\
\label{sec-1.8.6.3}

用MS Windows下的压缩软件winzip压缩的文件如何在Linux系统下展开呢？可以用unzip命令，该命令用于解扩展名为.zip的压缩文件。

　　语法：unzip ［选项］ 压缩文件名.zip

　　各选项的含义分别为：

　　-x 文件列表 解压缩文件，但不包括指定的file文件。

　　-v 查看压缩文件目录，但不解压。

　　-t 测试文件有无损坏，但不解压。

　　-d 目录 把压缩文件解到指定目录下。

　　-z 只显示压缩文件的注解。

　　-n 不覆盖已经存在的文件。

　　-o 覆盖已存在的文件且不要求用户确认。

　　-j 不重建文档的目录结构，把所有文件解压到同一目录下。

　　例1：将压缩文件text.zip在当前目录下解压缩。

　　\$ unzip text.zip

　　例2：将压缩文件text.zip在指定目录/tmp下解压缩，如果已有相同的文件存在，要求unzip命令不覆盖原先的文件。

　　\$ unzip -n text.zip -d /tmp

　　例3：查看压缩文件目录，但不解压。

　　\$ unzip -v text.zip

\end{itemize} % ends low level

\subsection{使用 vi 编辑器的运行、编辑和保存文本文件}
\label{sec-1.9}

文本编辑器有很多，比如图形模式的gedit、kwrite、OpenOffice \ldots{} \ldots{} ，文本模式下的编辑器有vi、vim（vi的增强版本）和nano \ldots{} \ldots{} vi和vim是我们在Linux中最常用的编辑器。
nano 工具和DOS操作系统下的edit操作相似，使用简单，可以作为入门的编辑器来使用。
\subsubsection{如何调用vi}
\label{sec-1.9.1}

    [root@localhost $\sim$]\# vi  filename
\subsubsection{vi 的三种命令模式}
\label{sec-1.9.2}

Command（命令）模式，用于输入命令；
Insert（插入）模式，用于插入文本；
Visual（可视）模式，用于视化的的高亮并选定正文；
\subsubsection{文件的保存和退出}
\label{sec-1.9.3}

Command 模式是vi或vim的默认模式，如果我们处于其它命令模式时，要通过ESC键切换过来。
当我们按ESC键后，接着再输入:号时，vi会在屏幕的最下方等待我们输入命令；
:w  保存；
:w  filename 另存为filename；
:wq! 保存退出；
:wq! filename 注：以filename为文件名保存后退出；
:q! 不保存退出；
:x 应该是保存并退出 ，功能和:wq!相同
\subsubsection{光标移动}
\label{sec-1.9.4}

当我们按ESC进入Command模式后，我们可以用下面的一些键位来移动光标；

j 向下移动一行；

k 向上移动一行；

h 向左移动一个字符；

l 向右移动一个字符；

ctrl+b  向上移动一屏；

ctrl+f  向下移动一屏；

向上箭头    向上移动；

向下箭头    向下移动；

向左箭头    向左移动；

向右箭头    向右移动；
\subsubsection{插入模式（文本的插入）}
\label{sec-1.9.5}

i  在光标之前插入；
a  在光标之后插入；

\subsubsection{文本内容的删除操作}
\label{sec-1.9.6}

x 一个字符；

dd 删除一行；

d\$ 删除光标到行尾的内容；

\subsubsection{恢复修改及恢复删除操作}
\label{sec-1.9.7}

u  撤消修改或删除操作；
按ESC键返回Command（命令）模式，然后按u键来撤消删除以前的删除或修改；如果您想撤消多个以前的修改或删除操作，请按多按几次u。
\subsubsection{可视模式}
\label{sec-1.9.8}

在最新的Linux发行版本中，vi提供了可视模式，因为这个功能是vim才有的。如果您用的vi没有这个功能，就换成vim就有了。打开可视模式，按ESC键，然后按v就进入可视模式；
可视模式为我们提供了极为友好的选取文本范围，以高亮显示；在屏幕的最下方显示有:-- 可视 --

\subsubsection{复制和粘帖的操作}
\label{sec-1.9.9}

选中内容后，按y就表示复制；按d表示删除；
p 在光标之后粘帖；

\subsubsection{查找和替换功能}
\label{sec-1.9.10}

\begin{itemize}

\item 查找\\
\label{sec-1.9.10.1}

首先，我们要进入ESC键，进入命令模式；我们输入/或?就进入查找模式了；

/SEARCH  注：正向查找，按n键把光标移动到下一个符合条件的地方；

?SEARCH  注：反向查找，按shift+n 键，把光标移动到下一个符合条件的

\item 替换\\
\label{sec-1.9.10.2}

按ESC键进入命令模式；

:s /SEARCH/REPLACE/g  注：把当前光标所处的行中的SEARCH单词，替换成REPLACE，并把所有SEARCH高亮显示；

:\%s /SEARCH/REPLACE  注：把文档中所有SEARCH替换成REPLACE；

:\#,\#s/SEARCH/REPLACE/g  注：\#号表示数字，表示从多少行到多少行，把SEARCH替换成REPLACE；

注：在这之中，g表示全局查找；我们注意到，就是没有替换的地方，也会把SEARCH高亮显示；

\end{itemize} % ends low level


\subsection{使用正则表达式(regular expression pattern matching)}
\label{sec-1.10}

正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。
\subsubsection{历史和起源}
\label{sec-1.10.1}
正则表达式的“鼻祖”或许可一直追溯到科学家对人类神经系统工作原理的早期研究。美国新泽西州的Warren McCulloch和出生在美国底特律的Walter Pitts这两位神经生理方面的科学家，研究出了一种用数学方式来描述神经网络的新方法，他们创新地将神经系统中的神经元描述成了小而简单的自动控制元，从而作出了一项伟大的工作革新。

在1956 年,出生在被马克・吐温（Mark Twain）称为“美国最美丽的城市之一的”哈特福德市的一位名叫Stephen Kleene的数学科学家，他在Warren McCulloch和Walter Pitts早期工作的基础之上，发表了一篇题目是《神经网事件的表示法》的论文，利用称之为正则集合的数学符号来描述此模型，引入了正则表达式的概念。正则表达式被作为用来描述其称之为“正则集的代数”的一种表达式，因而采用了“正则表达式”这个术语。

之后一段时间，人们发现可以将这一工作成果应用于其他方面。Ken Thompson就把这一成果应用于计算搜索算法的一些早期研究，Ken Thompson是 Unix的主要发明人，也就是大名鼎鼎的Unix之父。Unix之父将此符号系统引入编辑器QED，然后是Unix上的编辑器ed，并最终引入grep。Jeffrey Friedl 在其著作“Mastering Regular Expressions (2nd edition)”中对此作了进一步阐述讲解，如果你希望更多了解正则表达式理论和历史，推荐你看看这本书。

自此以后，正则表达式被广泛地应用到各种UNIX或类似于UNIX的工具中，如大家熟知的Perl。Perl的正则表达式源自于Henry Spencer编写的regex，之后已演化成了pcre（Perl兼容正则表达式Perl Compatible Regular Expressions），pcre是一个由Philip Hazel开发的、为很多现代工具所使用的库。正则表达式的第一个实用应用程序即为Unix中的 qed 编辑器。

\subsubsection{基础的基础}
\label{sec-1.10.2}

正则表达式由一些普通字符和一些元字符（metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义。

在最简单的情况下，一个正则表达式看上去就是一个普通的查找串。例如，正则表达式''testing''中没有包含任何元字符，它可以匹配''testing''和''123testing''等字符串，但是不能匹配''Testing''。
普通字符由所有那些未显式指定为元字符的打印和非打印字符组成。这包括所有的大写和小写字母字符，所有数字，所有标点符号以及一些符号。

非打印字符:

$\backslash$cx  匹配由x指明的控制字符。例如， $\backslash$cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 `'c'' 字符。
$\backslash$f  匹配一个换页符。等价于 $\backslash$x0c 和 $\backslash$cL。
$\backslash$n  匹配一个换行符。等价于 $\backslash$x0a 和 $\backslash$cJ。
$\backslash$r  匹配一个回车符。等价于 $\backslash$x0d 和 $\backslash$cM。
$\backslash$s  匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ $\backslash$f$\backslash$n$\backslash$r$\backslash$t$\backslash$v]。
$\backslash$S  匹配任何非空白字符。等价于 [\^{} $\backslash$f$\backslash$n$\backslash$r$\backslash$t$\backslash$v]。
$\backslash$t  匹配一个制表符。等价于 $\backslash$x09 和 $\backslash$cI。
$\backslash$v  匹配一个垂直制表符。等价于 $\backslash$x0b 和 $\backslash$cK。

\subsubsection{元字符}
\label{sec-1.10.3}

\$ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 \$ 也匹配 `'$\backslash$n'' 或 `'$\backslash$r''。要匹配 \$ 字符本身，请使用 $\backslash$\$。

( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 $\backslash$( 和 $\backslash$)。

* 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 $\backslash$*。

+ 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 $\backslash$+。

. 匹配除换行符 $\backslash$n之外的任何单字符。要匹配 .，请使用 $\backslash$.。

[  标记一个中括号表达式的开始。要匹配 [，请使用 $\backslash$[。

? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 $\backslash$?。

$\backslash$ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， `'n'' 匹配字符 `'n''。''$\backslash$n'' 匹配换行符。序列 `'$\backslash$'' 匹配 ``$\backslash$''，而 `'$\backslash$('' 则匹配 "("。

\^{} 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 \^{} 字符本身，请使用 $\backslash$\^{}。

\{ 标记限定符表达式的开始。要匹配 \{，请使用 $\backslash$\{。

| 指明两项之间的一个选择。要匹配 |，请使用 $\backslash$|。

\subsubsection{限定符}
\label{sec-1.10.4}

　　限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或\{n\}或\{n,\}或\{n,m\}共6种。

 *、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。

　　正则表达式的限定符有：
　
 *  匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于\{0,\}。

+  匹配前面的子表达式一次或多次。例如，''zo+'' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 \{1,\}。

?  匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 \{0,1\}。

\{n\}  n 是一个非负整数。匹配确定的 n 次。例如，''o\{2\}'' 不能匹配 "Bob" 中的 ''o''，但是能匹配 "food" 中的两个 o。

\{n,\}  n 是一个非负整数。至少匹配n 次。例如，''o\{2,\}'' 不能匹配 "Bob" 中的 ''o''，但能匹配 "foooood" 中的所有 o。''o\{1,\}'' 等价于
''o+''。''o\{0,\}'' 则等价于 ''o*''。

\{n,m\}  m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o\{1,3\}" 将匹配 "fooooood" 中的前三个 o。''o\{0,1\}''
等价于 ''o?''。请注意在逗号和两个数之间不能有空格。

\subsubsection{例子}
\label{sec-1.10.5}

grep r.t test.txt

　　在test.txt文件中的每一行中搜索正则表达式r.t，并打印输出匹配的行。正则表达式r.t匹配一个r接着任何一个字符再接着一个t。所以它将匹配文件中的rat和rut，而不能匹配Rotten中的Rot，因为正则表达式是大小写敏感的。要想同时匹配大写和小写字母，应该使用字符区间元字符（方括号）。正则表达式[Rr]能够同时匹配R和r。所以，要想匹配一个大写或者小写的r接着任何一个字符再接着一个t就要使用这个表达式：[Rr].t。

sed 's//\^{}\$//d' price.txt  删除所有空行

sed 's//\^{}[ $\backslash$t]*\$//d' price.txt    删除所有只包含空格或者制表符的行

sed 's//"////g' price.txt  删除所有引号

\subsubsection{常用的正则表达式}
\label{sec-1.10.6}

匹配中文字符的正则表达式： [$\backslash$u4e00-$\backslash$u9fa5]

获取日期正则表达式：$\backslash$d\{4\}[年|$\backslash$-|$\backslash$.]$\backslash$d\{1,2\}[月|$\backslash$-|$\backslash$.]$\backslash$d\{1,2\}日?

匹配双字节字符(包括汉字在内)：[\^{}$\backslash$x00-$\backslash$xff]

匹配空白行的正则表达式：$\backslash$n$\backslash$s*$\backslash$r

匹配首尾空白字符的正则表达式：\^{}$\backslash$s*|$\backslash$s*\$

匹配Email地址的正则表达式：$\backslash$w+([-+.]$\backslash$w+)*@$\backslash$w+([-.]$\backslash$w+)*$\backslash$.$\backslash$w+([-.]$\backslash$w+)*

匹配网址URL的正则表达式：[a-zA-z]+://[\^{}$\backslash$s]*

匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：\^{}[a-zA-Z][a-zA-Z0-9\_]\{4,15\}\$

匹配国内电话号码：$\backslash$d\{4\}-$\backslash$d\{7\}|$\backslash$d\{3\}-$\backslash$d\{8\}

匹配中国邮政编码：[1-9]$\backslash$d(?!$\backslash$d)

匹配身份证：$\backslash$d\{17\}[$\backslash$d|X]|$\backslash$d\{15\}

匹配ip地址：((2[0-4]\d|25[0-5]|[1]?$\backslash$d$\backslash$d?)$\backslash$.)\{3\}(2[0-4]\d|25[0-5]|[1]?$\backslash$d$\backslash$d?)

\subsection{过滤和处理文本}
\label{sec-1.11}

\subsubsection{grep、fgrep和egrep命令}
\label{sec-1.11.1}

grep （global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。Unix的grep家族包 括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能 更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。

grep的工作方式是这样的:它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到屏幕，不影响原文件内容。
grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。
grep命令一次只能搜索一个指定的模式；egrep命令检索扩展的正则表达式（包括表达式组和可选项）；fgrep命令检索固定字符串，它不识别正则表达式，是快速搜索命令。
这组命令在指定的输入文件中查找与模式匹配的行。如果没有指定文件，则从标准输入中读取。正常情况下，每个匹配的行被显示到标准输出。如果要查找的文件是多个，则在每一行输出之前加上文件名。

语法：

grep ［选项］ ［查找模式］ ［文件名1，文件名2，……］

egrep ［选项］ ［查找模式］ ［文件名1，文件名2，……］

fgrep ［选项］ ［查找模式］ ［文件名1，文件名2，……］

这组命令各选项的含义为：

　　- E 每个模式作为一个扩展的正则表达式对待。

　　- F 每个模式作为一组固定字符串对待（以新行分隔），而不作为正则表达式。

　　- b在输出的每一行前显示包含匹配字符串的行在文件中的字节偏移量。

　　- c 只显示匹配行的数量。

　　- i 比较时不区分大小写。

　　- h 在查找多个文件时，指示grep不要将文件名加入到输出之前。

　　- l 显示首次匹配串所在的文件名并用换行符将其隔开。当在某文件中多次出现匹配串时，不重复显示此文件名。

　　- n 在输出前加上匹配串所在行的行号（文件首行行号为1）。

　　- v 只显示不包含匹配串的行。

　　- x 只显示整行严格匹配的行。

　　- e expression 指定检索使用的模式。用于防止以“-”开头的模式被解释为命令选项。

　　- f expfile 从expfile文件中获取要搜索的模式，一个模式占一行。

对该组命令的使用还需注意以下方面：

在命令后键入搜索的模式，再键入要搜索的文件。其中，文件名列表中也可以使用特殊字符，如“*”等，用来生成文件名列表。如果想在搜索的模式中包含有空格的字符串，可以用单引号把要搜索的模式括起来，用来表明搜索的模式是由包含空格的字符串组成。否则，Shell将把空格认为是命令行参数的定界符，而grep命令将把搜索模式中的单词解释为文件名列表中的一部分。在下面的例子中，grep命令在文件example中搜索模式“text file”。

\$ grep ’text file’ example

用户可以在命令行上用Shell特殊字符来生成将要搜索的文件名列表。在下面的例子中，特殊字符“*”用来生成一个文件名列表，该列表包含当前目录下所有的文件。该命令将搜索出当前目录下所有文件中与模式匹配的行。

\$ grep data *

特殊字符在搜索一组指定的文件时非常有用。例如，如果想搜索所有的C程序源文件中特定的模式，您可以用“*.c”来指定文件名列表。假设用户的 C程序中包含一些不必要的转向语句（goto语句），想要找到这些语句，可以用如下的命令来搜索并显示所有包含goto语句的代码行：

\$ grep goto *.c

用户可以在命令行上键入搜索模式，也可以使用-f选项从指定文件中读取要搜索的模式。在文件中，每个搜索模式占一行。如果经常要搜索一组常见字符串时，这个功能非常有用。在下面的例子中，用户要在文件exam中搜索字符串“editor”和“create”，就把要搜索的模式放置在文件mypats中，然后，grep命令从文件mypats中读取要搜索的模式。

\$ cat mypats

editor

create

\$ grep -f mypats exam

\subsubsection{sed}
\label{sec-1.11.2}

sed 是一个非交互式上下文(context)编辑器，它被设计在下列三种情况下发挥作用:

 '.' 编辑那些对舒适的交互式编辑而言太大的文件。

 '.' 在编辑命令太复杂而难于在交互模式下键入的时候编辑任何大小的文件。

 '.' 要在对输入的一趟扫描中有效的进行多个‘全局’(global)编辑函数。

因为每次只把输入的某些行驻留在内存中，并且不使用临时文件，所以可编辑的文件的有效大小，只受限于输入和输出要同时共存于次级存储的要求。
可以单独的建立复杂的编辑脚本并作为给 sed 的命令文件。对于复杂的编辑，这节省了可观的键入和随之而来的错误。从命令文件运行 sed 高效于作者所知道的任何交互式编辑器，甚至包括能用预先写好的脚本驱动的编辑器。

相较于交互式编辑器而言，根本性的损失是缺乏相对地址(由于操作是每次一行的)，和缺乏对命令如期运行的立即验证。

sed 是 UNIX 编辑器 ed 的直系后代。由于在交互式和非交互式操作之间的差异，在 ed 和 sed 之间已经有了可观的变化；在两个编辑器之间最显著的家族性共同之处，在于他们所识别的模式(‘正则表达式’)的种类；匹配模式的代码可以从 ed 的代码几乎原封不动的复制过来。


sed [-nefr] [动作]

参数：

-n  ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN
的数据一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过
sed 特殊处理的那一行(或者动作)才会被列出来。

-e  ：直接在指令列模式上进行 sed 的动作编辑；

-f  ：直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的
sed 动作；

-r  ：sed 的动作支持的是延伸型正则表达式的语法。(预设是基础正则表达式语法)

-i  ：直接修改读取的档案内容，而不是由屏幕输出。

动作说明：  [n1[,n2]]function

n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作
是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』

function 有：

a   ：新增， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)～

c   ：取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！

d   ：删除，因为是删除啊，所以 d 后面通常不接任何东西；

i   ：插入， i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)；

p   ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作～

s   ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正则表达式！例如 1,20s/old/new/g

以下的是替换标记

g   ：表示行内全面替换。

p   ：表示打印行。

w   ：表示把行写入一个文件。

q    ：退 出Sed


范例一：将 /etc/passwd 的内容列出，并且打印行号，同时，请将第 2$\sim$5行删除！
nl /etc/passwd | sed '2,5d'


范例二：承上题，在第二行后(亦即是加在第三行)加上『drink tea?』
nl /etc/passwd | sed '2a drink tea'


范例三：在第二行后面加入两行字，例如『Drink tea or .....』『drink beer?』
nl /etc/passwd | sed '2a Drink tea or ......$\backslash$
 > drink beer ?'

范例四：我想将第2$\sim$5行的内容取代成为『No 2$\sim$5 number』
nl /etc/passwd | sed '2,5c No 2-5 number'


范例五：仅列出第 5$\sim$7 行
nl /etc/passwd | sed -n '5,7p'


范例六：我们可以使用 ifconfig 来列出 IP ，若仅要 eth0 的 IP
[root@linux $\sim$]\# ifconfig eth0
eth0      Link encap:Ethernet  HWaddr 00:51:FD:52:9A:CA
inet addr:192.168.1.12  Bcast:192.168.1.255  Mask:255.255.255.0

ifconfig eth0 | grep 'inet ' | sed 's/\^{}.*addr://g' | $\backslash$
> sed 's/Bcast.*\$//g'

范例七：将 /etc/man.config 档案的内容中，有 MAN 的设定就取出来，但不要说明内容。
cat /etc/man.config | grep 'MAN'| sed 's/\#.*\$//g' | $\backslash$
> sed '/\^{}\$/d'


范例八：利用 sed 直接在 $\sim$/.bashrc 最后一行加入『\# This is a test』
sed -i '\$a \# This is a test'  $\sim$/.bashrc

范例九：将所有loveable替换成lovers
sed -n 's/$\backslash$(love$\backslash$)able/$\backslash$1rs/p' example

范例十：所有以192.168.0.1开头的行 都替换成它自已加 localhost，变成192.168.0.1localhost
sed `s/\^{}192.168.0.1/\&localhost/' example


范例十一：打印完第10行后，退出sed。
sed `10q' example

\subsubsection{awk}
\label{sec-1.11.3}

awk是一种程序语言，对文档资料的处理具有很强的功能。awk名称是由它三个最初设计者的姓氏的第一个字母而命名的： Alfred V. Aho、Peter J. We i n b e rg e r、Brian W. Kernighan。

gawk 的主要功能是针对文件的每一行( l i n e )，也就是每一条记录，搜寻指定的格式。当某一行符合指定的格式时，gawk 就会在此行执行被指定的动作。gawk 依此方式自动处理输入文件的每一行直到输入文件档案结束。

gawk经常用在如下的几个方面：

 根据要求选择文件的某几行，几列或部分字段以供显示输出。

 分析文档中的某一个字出现的频率、位置等。

 根据某一个文档的信息准备格式化输出。

 以一个功能十分强大的方式过滤输出文档。

 根据文档中的数值进行计算。

awk `条件类型1\{动作1\} 条件类型2\{动作2\} \ldots{}' filename

范例：
[root@linux $\sim$]\# last

dmtsai   pts/0        192.168.1.12     Mon Aug 22 09:40   still logged in

root       tty1                                    Mon Aug 15 11:38 - 11:39  (00:01)

reboot   system boot  2.6.11           Sun Aug 14 18:18         (7+15:41)

dmtsai   pts/0        192.168.1.12     Fri Aug 12 12:07   - 12:08  (00:01)

[root@linux $\sim$]\# last | awk `\{print \$1 ``\t'' \$3\}'

dmtsai  192.168.1.12

root       Mon

reboot   boot

dmtsai  192.168.1.12

整个 awk 的处理流程是：

读入第一行，并将第一行的资料填入 \$0, \$1, \$2\ldots\{\}. 等变数当中，第一行的 \$0 代表的就是『dmtsai pts/0\ldots{}. 』那一行；

依据 ``条件类型'' 的限制，判断是否需要进行后面的 ``动作''；

做完所有的动作与条件类型；

若还有后续的『行』的数据，则重复上面 1$\sim$3 的步骤，直到所有的数据都读完为止。

所以，awk 是『以行为一次处理的单位』， 而『以字段为最小的处理单位』。


awk 的内建变量

变量名称        代表意义

NF      每一行 (\$0) 拥有的字段总数

NR      目前 awk 所处理的是『第几行』数据

FS      目前的分隔字符，预设是空格键

范例： last | awk `\{print \$1 ``\t lines: `` NR ``\t columes: `` NF\}'

awk 的逻辑运算字符

运算单元        代表意义

>       大于

<       小于

>=      大于或等于

<=      小于或等于

==      等于

!=      不等于

范例一：

cat /etc/passwd | \textbackslash{}

> awk `\{FS='':''\} \$3 < 10 \{print \$1 ``\textbackslash{}t `` \$3\}'


正确写法是

cat /etc/passwd | \textbackslash{}

> awk `BEGIN \{FS='':''\} \$3 < 10 \{print \$1 ``\textbackslash{}t `` \$3\}'


范例二：

想要计算每个人的总额，而且还想要格式化输出

cat pay.txt | \textbackslash{}

> awk `NR==1\{printf ``\%10s \%10s \%10s \%10s \%10s\textbackslash{}n'',\$1,\$2,\$3,\$4,''Total'' \}

NR>=2\{total = \$2 + \$3 + \$4

printf ``\%10s \%10d \%10d \%10d \%10.2f\textbackslash{}n'', \$1, \$2, \$3, \$4, total\}'

Name        1st            2nd          3th        Total

VBird         23000      24000      25000   72000.00

DMTsai      21000     20000       23000   64000.00

Bird2         43000      42000      41000   126000.00

上面的例子有几个重要事项应该要先说明的：

所有的动作，亦即在 \{\} 内的动作，如果有需要多个指令辅助时，可利用分号『;』间隔， 或者直接以 [Enter] 按键来隔开每个指令，例如上面的 NR>=2 后面接的动作， 利用 total = \ldots{} 那个指令来指定加总，而后续则以 printf 来格式化输出！

逻辑运算当中，如果是『等于』的情况，则务必使用两个等号『==』！

格式化输出时，在 printf 的格式设定当中，务必加上 \textbackslash{}n，才能进行分行！

与 bash shell 的变量不同，在 awk当中，变量可以直接使用，不需加上 \$ 符号。

另外， awk 的动作内 \{\} 也是支持 if (条件)

\subsection{用标准的输入 / 输出接口及管道连接程序和文件}
\label{sec-1.12}

\subsubsection{重定向标准 I/O}
\label{sec-1.12.1}
Linux shell（比如 Bash）接收或发送序列和字符串流 形式的输入或输出。每个字符都独立于与之相邻的字符。字符没有被组织成结构化记录或固定大小的块。不管实际的字符串流进入或来自文件、键盘、显示窗口或其他 I/O 设备，都使用文件 I/O 技术来访问流。Linux shell 使用 3 种标准的 I/O 流，每种流都与一个文件描述符相关联：

stdout 是标准输出流，它显示来自命令的输出。它的文件描述符为 1。

stderr 是标准错误流，它显示来自命令的错误输出。它的文件描述符为 2。

stdin 是标准输入流，它为命令提供输入。它的文件描述符为 0。

输入流通常通过终端击键为程序提供输入。输出流通常向终端输出文本字符。最初的终端是 ASCII 打字机或显示终端，但现在更多是指图形桌面上的文本窗口。
\subsubsection{重定向输出}
\label{sec-1.12.2}

可以通过两种方法将输出重定向到文件：

n>

将输出从文件描述符 n

重定向到文件。您必须具有该文件的写权限。如果该文件不存在，将创建它。如果该文件已经存在，通常将覆盖所有现有内容，并且没有任何警告。

n>>

还可以将输出从文件描述符 n

重定向到一个文件中。这里也一样要求您具有该文件的写权限。如果该文件不存在，将创建它。如果该文件已经存在，输出将附加到现有的内容后面。

在 n> 或 n>> 中的 n 引用文件描述符。如果省略它，将执行标准输出。

\begin{itemize}

\item 输出重定向\\
\label{sec-1.12.2.1}

[ian@echidna lpi103-4]\$ ls x* z*

ls: cannot access z*: No such file or directory

xaa  xab

[ian@echidna lpi103-4]\$ ls x* z* >stdout.txt 2>stderr.txt

[ian@echidna lpi103-4]\$ ls w* y*

ls: cannot access w*: No such file or directory

yaa  yab

[ian@echidna lpi103-4]\$ ls w* y* >>stdout.txt 2>>stderr.txt

[ian@echidna lpi103-4]\$ cat stdout.txt

xaa

xab

yaa

yab

[ian@echidna lpi103-4]\$ cat stderr.txt

ls: cannot access z*: No such file or directory

ls: cannot access w*: No such file or directory

\item 将两个流重定向到一个文件中\\
\label{sec-1.12.2.2}
[ian@echidna lpi103-4]\$ ls x* z* \&>output.txt

[ian@echidna lpi103-4]\$ cat output.txt

ls: cannot access z*: No such file or directory

xaa

xab

[ian@echidna lpi103-4]\$ ls x* z* >output.txt 2>\&1

[ian@echidna lpi103-4]\$ cat output.txt

ls: cannot access z*: No such file or directory

xaa

xab

[ian@echidna lpi103-4]\$ ls x* z* 2>\&1 >output.txt \# stderr does not go to output.txt

ls: cannot access z*: No such file or directory

[ian@echidna lpi103-4]\$ cat output.txt

xaa

xab

\end{itemize} % ends low level

\subsubsection{重定向输入}
\label{sec-1.12.3}
就像可以重定向 stdout 和 stderr 流一样，我们也可以使用 < 操作符从文件重定向 stdin。使用输入重定向将空格转换成制表符。

[ian@echidna lpi103-4]\$ tr ` ` `$\backslash$t'<text1

1       apple

2       pear

3       banana

Shell（包括 bash）还有存在 here-document 的概念，它是另一种输入重定向形式。它将 << 和一个单词（比如 END）结合构成一个标记，用来表示输入端。我们在清单 8 中对此进行演示。

使用 here-document 的输入重定向

[ian@echidna lpi103-4]\$ sort -k2 <<END

> 1 apple

> 2 pear

> 3 banana

> END

1 apple

3 banana

2 pear

\subsubsection{管道}
\label{sec-1.12.4}

在两个命令之间使用管道 | 操作符将的一个命令的 stdout 指向第二个命令的 stdin。您可以通过添加更多的命令和管道操作符来构造更长的管道线。任何命令都可能包含选项或参数。许多命令使用连字符 (-) 取代文件名作为一个参数，用于表示输入来自 stdin 而不是文件。查看手册页确保正确使用命令。构造由多个命令（每个命令都有特定的功能）组成的长管道线是在 Linux 和 UNIX 中用于完成任务的常见方法。假设管道线中，command2 和 command3 都带有参数，但 command3 仅使用 - 参数表示来自 stdin 的输入。

通过管道从几个命令导出输出

command1 | command2 paramater1 | command3 parameter1 - parameter2 | command4

需要说明的是，管道线仅将 stdout 导向 stdin。您不能使用 2| 单独导出 stderr，至少使用我们目前所了解的工具还不能这样做。如果 stderr 已被重定向到 stdout，那么两个流都会被通过管道导出。

[ian@echidna lpi103-4]\$ ls y* x* z* u* q*

ls: cannot access z*: No such file or directory

ls: cannot access u*: No such file or directory

ls: cannot access q*: No such file or directory

xaa  xab  yaa  yab

[ian@echidna lpi103-4]\$ ls y* x* z* u* q*  2>\&1 |sort

ls: cannot access q*: No such file or directory

ls: cannot access u*: No such file or directory

ls: cannot access z*: No such file or directory

xaa

xab

yaa

yab

Linux 和 UNIX 系统中的管道的优点之一是，与其他流行的操作系统不同，它们的管道不涉及到中间文件。第一个命令的 stdout 没有写到一个文件中，然后再由第二个命令读取。可以使用这样的管道：

bunzip2 -c somefile.tar.bz2 | tar -xvf -

\subsection{控制系统进程}
\label{sec-1.13}

\subsubsection{ps命令}
\label{sec-1.13.1}

\begin{itemize}

\item ps简介\\
\label{sec-1.13.1.1}

前面介绍的两个命令都是用于查看当前系统用户的情况，下面就来看看进程的情况，这也是本章的主题。要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而ps命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。


\item ps命令及其参数\\
\label{sec-1.13.1.2}


ps命令最常用的还是用于监控后台进程的工作情况，因为后台进程是不和屏幕键盘这些标准输入/输出设备进行通信的，所以如果需要检测其情况，便可以使用ps命令了。

该命令语法格式如下：

ps ［选项］

下面对命令选项进行说明：

-e 显示所有进程。

-f 全格式。

-h 不显示标题。

-l 长格式。

-w 宽输出。

a 显示终端上的所有进程，包括其他用户的进程。

r 只显示正在运行的进程。

x 显示没有控制终端的进程。
\end{itemize} % ends low level
\subsubsection{top命令}
\label{sec-1.13.2}


top命令和ps命令的基本作用是相同的，显示系统当前的进程和其他状况；但是top是一个动态显示过程，即可以通过用户按键来不断刷新当前状态。如果在前台执行该命令，它将独占前台，直到用户终止该程序为止。

比较准确的说，top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用。内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。在后面的介绍中将把命令参数和交互命令分开讲述。

下面是该命令的语法格式：

top ［-］ ［d delay］ ［q］ ［c］ ［s］ ［S］ ［i］

d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。

q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。

S 指定累计模式。

s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。

i 使top不显示任何闲置或者僵死进程。

c 显示整个命令行而不只是显示命令名

top命令显示的项目很多，默认值是每5秒更新一次，当然这是可以设置的。显示的各项目为：

uptime 该项显示的是系统启动时间、已经运行的时间和三个平均负载值（最近1秒，5秒，15秒的负载值）。

processes 自最近一次刷新以来的运行进程总数。当然这些进程被分为正在运行的，休眠的，停止的等很多种类。进程和状态显示可以通过交互命令t来实现。

CPU states 显示用户模式，系统模式，优先级进程（只有优先级为负的列入考虑）和闲置等各种情况所占用CPU时间的百分比。优先级进程所消耗的时间也被列入到用户和系统的时间中，所以总的百分比将大于100\%。

Mem 内存使用情况统计，其中包括总的可用内存，空闲内存，已用内存，共享内存和缓存所占内存的情况。

Swap 交换空间统计，其中包括总的交换空间，可用交换空间，已用交换空间。

PID 每个进程的ID。

PPID 每个进程的父进程ID。

UID 每个进程所有者的UID 。

USER 每个进程所有者的用户名。

PRI 每个进程的优先级别。

NI 该进程的优先级值。

SIZE 该进程的代码大小加上数据大小再加上堆栈空间大小的总数。单位是KB。

TSIZE 该进程的代码大小。对于内核进程这是一个很奇怪的值。

DSIZE 数据和堆栈的大小。

TRS 文本驻留大小。

D 被标记为“不干净”的页项目。

LIB 使用的库页的大小。对于ELF进程没有作用。

RSS 该进程占用的物理内存的总数量，单位是KB。

SHARE 该进程使用共享内存的数量。

STAT 该进程的状态。其中S代表休眠状态；D代表不可中断的休眠状态；R代表运行状态；Z代表僵死状态；T代表停止或跟踪状态。

TIME 该进程自启动以来所占用的总CPU时间。如果进入的是累计模式，那么该时间还包括这个进程子进程所占用的时间。且标题会变成CTIME。

\%CPU 该进程自最近一次刷新以来所占用的CPU时间和总时间的百分比。

\%MEM 该进程占用的物理内存占总内存的百分比。

COMMAND 该进程的命令名称，如果一行显示不下，则会进行截取。内存中的进程会有一个完整的命令行。

top命令执行过程中可以使用的一些交互命令。从使用角度来看，熟练的掌握这些命令比掌握选项还重要一些。这些命令都是单字母的，如果在命令行选项中使用了s选项，则可能其中一些命令会被屏蔽掉。

<空格> 立即刷新显示。

Ctrl+L 擦除并且重写屏幕。

h或者? 显示帮助画面，给出一些简短的命令总结说明。

k 终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽。

i 忽略闲置和僵死进程。这是一个开关式命令。

q 退出程序。

r 重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10。

S 切换到累计模式。

s 改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加。

f或者F 从当前显示中添加或者删除项目。

o或者O 改变显示项目的顺序。

l 切换显示平均负载和启动时间信息。

m 切换显示内存信息。

t 切换显示进程和CPU状态信息。

c 切换显示命令名称和完整命令行。

M 根据驻留内存大小进行排序。

P 根据CPU使用百分比大小进行排序。

T 根据时间/累计时间进行排序。

W 将当前设置写入$\sim$/.toprc文件中。这是写top配置文件的推荐方法。
\subsubsection{后台执行}
\label{sec-1.13.3}

当您在终端里运行一个命令或开启一个程序时，终端要等到命令或程序运行完毕后，才能再被使用。在 Unix 中，我们称这样的命令或程序在前台(foreground)运行。如果您想在终端下运行另一个命令，则需要再打开一个新的终端。但这里还有一个更优雅的办法，称为任务调度(jobbing)或后台(backgrounding)。当您运用任务的调度或将命令置于后台，终端就立即解放了，这样一来，终端立即就可以接受新的输入。为实现这样的目的，您只需在命令后面添加一个 ``\&''。

命令 jobs 将告诉在这个终端窗口中，运行着哪些命令与程序。

组合键 <CTRL z> 将挂起终端中正在运行的程序

\subsubsection{kill命令}
\label{sec-1.13.4}


　　当需要中断一个前台进程的时候，通常是使用组合键；但是对于一个后台进程恐怕就不是一个组合键所能解决的了，这时就必须求助于kill命令。该命令可以终止后台进程。至于终止后台进程的原因很多，或许是该进程占用的CPU时间过多；或许是该进程已经挂死。总之这种情况是经常发生的。

　　kill命令是通过向进程发送指定的信号来结束进程的。如果没有指定发送信号，那么默认值为TERM信号。TERM信号将终止所有不能捕获该信号的进程。至于那些可以捕获该信号的进程可能就需要使用kill（9）信号了，该信号是不能被捕捉的。

　　kill命令的语法格式很简单，大致有以下两种方式：

　　kill ［-s 信号 | -p ］ ［ -a ］ 进程号 \ldots{}

　　kill -l ［信号］

　　-s 指定需要送出的信号。既可以是信号名也可以对应数字。

　　-p 指定kill命令只是显示进程的pid，并不真正送出结束信号。

　　-l 显示信号名称列表，这也可以在/usr/include/linux/signal.h文件中找到。

\subsubsection{nohup命令}
\label{sec-1.13.5}


　　理论上，我们一般退出Linux系统时，会把所有的程序全部结束掉，包括那些后台程序。但有时候，例如您正在编辑一个很长的程序，但是您下班或是有事需要先退出系统，这时您又不希望系统把您编辑那么久的程序结束掉，希望退出系统时，程序还能继续执行。这时，我们就可以使用nohup命令使进程在用户退出后仍继续执行。

　　一般这些进程我们都是让它在后台执行，结果则会写到用户自己的目录下的nohup.out这个文件里（也可以使用输出重定向，让它输出到一个特定的文件）。
\subsubsection{renice命令}
\label{sec-1.13.6}


　　renice命令允许用户修改一个正在运行进程的优先权。

　　利用renice命令可以在命令执行时调整其优先权。其格式如下：

　　\$ renice -number PID

　　其中，参数number与nice命令的number意义相同。

　　注：

　　（1） 用户只能对自己所有的进程使用renice命令。

　　（2） root用户可以在任何进程上使用renice命令。

　　（3） 只有root用户才能提高进程的优先权。
\subsection{查询系统内的软件包}
\label{sec-1.14}

\subsubsection{RPM}
\label{sec-1.14.1}

\begin{itemize}

\item 查询RPM包内容\\
\label{sec-1.14.1.1}

　rpm -qpi Linux-1.4-6.i368.rpm
系统将会列出这个软件包的详细资料，包括含有多少个文件、各文件名称、文件大小、创建时间、编译日期等信息。
  rpm -qpl Linux-1.4-6.i368.rpm
查看软件包将会在系统里安装哪些部分

\item 安装RPM包\\
\label{sec-1.14.1.2}

　　RPM 软件包通常具有类似foo-1.0-1.i386.rpm 的文件名。其中包括 软件包的名称(foo)，版本号(1.0)，发行号(1)， 和 硬件平台(i386)。安装一个软件包只需简单的键入以下命令：

　　\$ rpm -ivh foo-1.0-1.i386.rpm

\item 卸载RPM包\\
\label{sec-1.14.1.3}

　　卸载软件包就象安装软件包时一样简单：

　　\$ rpm -e foo

　　注意这里使用软件包的名字name “foo”， 而不是软件包文件的名字file “foo-1.0-1.i386.rpm”。

　　如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。

\item 升级RPM包\\
\label{sec-1.14.1.4}

　　升级软件包和安装软件包十分类似：

　　\$ rpm -Uvh foo-2.0-1.i386.rpm


\item 查询已安装的软件包\\
\label{sec-1.14.1.5}

　　使用命令rpm -q来查询已安装软件包的数据库。简单的使用命令 rpm -q foo 会打印出foo软件包 的包名 ，版本号，和发行号：

　　\$ rpm -q foo

\item 查询所有已安装的软件包\\
\label{sec-1.14.1.6}

　　\$ rpm -qa

\item 查询文件所属的软件包\\
\label{sec-1.14.1.7}

如果您碰到了一个自己不认识的文件，要想查处它属于哪个软件包，您可以输入以下命令：

　　rpm -qf /usr/X11R6/bin/xxx
\end{itemize} % ends low level
\subsubsection{DEB}
\label{sec-1.14.2}

\begin{itemize}

\item apt-get\\
\label{sec-1.14.2.1}

apt-get install

下载 以及所有倚赖的包裹，同时进行包裹的安装或升级。如果某个包裹被设置了 hold (停止标志，就会被搁在一边(即不会被升级)。更多 hold 细节请看下面。

apt-get remove [--purge]

移除 以及任何倚赖这个包裹的其它包裹。

--purge 指明这个包裹应该被完全清除 (purged) ，更多信息请看 dpkg -P。

apt-get update

升级来自 Debian 镜像的包裹列表，如果你想安装当天的任何软件，至少每天运行一次，而且每次修改了
/etc/apt/sources.list 后，必须执行。

apt-get upgrade [-u]

升级所以已经安装的包裹为最新可用版本。不会安装新的或移除老的包裹。如果一个包改变了倚赖关系而需要安装一个新的包裹，那么它将不会被升级，而是标志为 hold。apt-get update 不会升级被标志为 hold 的包裹 (这个也就是 hold 的意思)。请看下文如何手动设置包裹为 hold。我建议同时使用 `-u' 选项，因为这样你就能看到哪些包裹将会被升级。

apt-get dist-upgrade [-u]

和 apt-get upgrade 类似，除了 dist-upgrade 会安装和移除包裹来满足倚赖关系。因此具有一定的危险性。

apt-cache search

搜索满足 的包裹和描述。

apt-cache show

显示 的完整的描述。

apt-cache showpkg

显示 许多细节，以及和其它包裹的关系。

\item dpkg\\
\label{sec-1.14.2.2}

安装一个 Debian 包裹文件，如你手动下载的文件。

dpkg -c

列出 的内容。

dpkg -I

从 中提取包裹信息。

dpkg -r

移除一个已安装的包裹。

dpkg -P

完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和可执行文件，purge 另外还删除所有的配制文件。

dpkg -L

列出 安装的所有文件清单。同时请看 dpkg -c 来检查一个 .deb 文件的内容。

dpkg -s

显示已安装包裹的信息。同时请看 apt-cache 显示 Debian 存档中的包裹信息，以及 dpkg -I 来显示从一个 .deb 文件中提取的包裹信息。

dpkg-reconfigure

重新配制一个已经安装的包裹，如果它使用的是 debconf (debconf 为包裹安装提供了一个统一的配制界面)。你能够重新配制 debconf 它本身，如你想改变它的前端或提问的优先权。例如，重新配制 debconf，使用一个 dialog 前端，简单运行：

dpkg-reconfigure --frontend=dialog debconf

\end{itemize} % ends low level

\subsection{使用网络应用程序和相关实用工具}
\label{sec-1.15}

\subsubsection{查看网络配置和网卡状态}
\label{sec-1.15.1}

ifconfig
ethtool eth0
\subsubsection{给网卡配置/删除ip}
\label{sec-1.15.2}

ifconfig eth0 192.168.8.42/16 给第一个网口配置ip和子网掩码(255.255.0.0)

ip addr del 192.168.8.43 dev eth0 删除第一个网口为192.168.8.43的ip

要使配置在重启后还生效，必须修改/etc/sysconfig/network-scripts下相应的配置文件
\subsubsection{ping命令}
\label{sec-1.15.3}
ping命令用于查看网络上的主机是否在工作，它向该主机发送ICMP\_ECHO\_REQUEST包。有时我们想从网络上的某台主机上下载文件，可是又不知道那台主机是否开着，就需要使用ping命令查看。

该命令的一般格式为：

ping ［选项］ 主机名/IP地址

命令中各选项的含义如下：

-c 数目 在发送指定数目的包后停止。

-d 设定SO\_DEBUG的选项。

-f 大量且快速地送网络封包给一台机器，看它的回应。

-I 秒数 设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。

-l 次数 在指定次数内，以最快的方式送封包数据到指定机器（只有超级用户可以使用此选项）。

-q 不显示任何传送封包的信息，只显示最后的结果。

-r 不经由网关而直接送封包到一台机器，通常是查看本机的网络接口是否有问题。

-s 字节数 指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。

\subsubsection{netstat命令　}
\label{sec-1.15.4}


netstat命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。

该命令的一般格式为：

netstat ［选项］

命令中各选项的含义如下：

-a 显示所有socket，包括正在监听的。

-c 每隔1秒就重新显示一遍，直到用户中断它。

-i 显示所有网络接口的信息，格式同“ifconfig -e”。

-n 以网络IP地址代替名称，显示出网络连接情形。

-r 显示核心路由表，格式同“route -e”。

-t 显示TCP协议的连接情况。

-u 显示UDP协议的连接情况。

-v 显示正在进行的工作。

［例］在本地机上使用netstat命令。

\$ netstat

Active Internet connections （w/o servers）

Proto Recv-Q Send-Q Local Address Foreign Address State

Active UNIX domain sockets （w/o servers）

Proto RefCnt Flags Type State I-Node Path

unix 1 ［ ］ STREAM CONNECTED 270 @00000008

unix 1 ［ ］ STREAM CONNECTED 150 @00000002

unix 1 ［ ］ STREAM CONNECTED 104 @00000001

unix 1 ［ ］ STREAM CONNECTED 222 @00000004

unix 1 ［ ］ STREAM CONNECTED 171 @00000003

unix 1 ［ ］ STREAM CONNECTED 271 /dev/log

unix 1 ［ ］ STREAM CONNECTED 225 /dev/log

unix 1 ［ ］ STREAM CONNECTED 223 /dev/log

unix 1 ［ ］ STREAM CONNECTED 203 /dev/log

unix 1 ［ ］ STREAM CONNECTED 105 /dev/log

……

\subsubsection{nslookup命令}
\label{sec-1.15.5}


nslookup命令的功能是查询一台机器的IP地址和其对应的域名。它通常需要一台域名服务器来提供域名服务。如果用户已经设置好域名服务器，就可以用这个命令查看不同主机的IP地址对应的域名。

该命令的一般格式为：

nslookup ［IP地址/域名］

［例］在本地机上使用nslookup命令。

\$ nslookup

Default Server: name.tlc.com.cn

Address: 192.168.1.99

>

在符号“>”后面输入要查询的IP地址或域名并回车即可。如果要退出该命令，输入exit并回车即可。

\subsection{安全传输文件}
\label{sec-1.16}

\subsubsection{openssh简介}
\label{sec-1.16.1}

OpenSSH 是 SSH （Secure SHell） 协议的免费开源实现。它用安全、加密的网络连接工具代替了 telnet、ftp、 rlogin、rsh 和 rcp 工具。OpenSSH 支持 SSH 协议的版本 1.3、1.5、和 2。自从 OpenSSH 的版本 2.9 以来，默认的协议是版本 2，该协议默认使用 RSA 钥匙。

\subsubsection{使用 ssh 命令}
\label{sec-1.16.2}


ssh 命令是 rlogin、rsh 和 telnet 命令的安全替换。它允许你在远程机器上登录并在其上执行命令。

使用 ssh 来登录到远程机器和使用 telnet 相似。要登录到一个叫做 penguin.example.net 的远程机器，在 shell 提示下键入下面的命令：

ssh penguin.example.net

第一次使用 ssh 在远程机器上登录时，你会看到和下面相仿的消息：

The authenticity of host penguin.example.net cant be established.

DSA key fingerprint is 94:68:3a:3a:bc:f3:9a:9b:01:5d:b3:07:38:e2:11:0c.

Are you sure you want to continue connecting (yes/no)?

键入 yes 来继续。这会把该服务器添加到你的已知主机的列表中，如下面的消息所示：

Warning: Permanently added penguin.example.net (RSA) to the list of known hosts.

下一步，你会看到向你询问远程主机口令的提示。在输入口令后，你就会在远程主机的 shell 提示下了。如果你没有指定用户名，你在本地客户机器上登录用的用户名就会被传递给远程机器。如果你想指定不同的用户名，使用下面的命令：

ssh username@penguin.example.net

你还可以使用 ssh -l username penguin.example.net。

ssh 命令可以用来在远程机器上不经 shell 提示登录而执行命令。它的语法格式是： ssh hostname command。譬如，如果你想在远程主机 penguin.example.net 上执行 ls /usr/share/doc 命令，在 shell 提示下键入下面的命令：

ssh penguin.example.net ls /usr/share/doc

在你输入了正确的口令之后， /usr/share/doc 这个远程目录中的内容就会被显示，然后你就会被返回到你的本地 shell 提示下。

\subsubsection{使用 scp 命令}
\label{sec-1.16.3}


scp 命令可以用来通过安全、加密的连接在机器间传输文件。它与 rcp 相似。

把本地文件传输给远程系统的一般语法是：

scp localfile username@tohostname:/newfilename

localfile 指定源文件，username@tohostname:/newfilename 指定目标文件。
要把本地文件 shadowman 传送到你在 penguin.example.net 上的账号内，在 shell 提示下键入（把 username 替换成你的用户名）：

scp shadowman username@penguin.example.net:/home/username

这会把本地文件 shadowman 传输给 penguin.example.net 上的 /home/username/shadowman 文件。

把远程文件传输给本地系统的一般语法是：

scp username@tohostname:/remotefile /newlocalfile

remotefile 指定源文件，newlocalfile 指定目标文件。

源文件可以由多个文件组成。譬如，要把目录 /downloads 的内容传输到远程机器 penguin.example.net 上现存的 uploads 目录，在 shell 提示下键入下列命令：

scp \emph{downloads/* username@penguin.example.net:/uploads}
\subsubsection{ssh 客户端}
\label{sec-1.16.4}

putty
scureCRT
\subsection{掌握提供给用户的系统工具}
\label{sec-1.17}

\subsubsection{uptime命令}
\label{sec-1.17.1}


uptime命令显示系统已经运行了多长时间，它依次显示下列信息：现在时间、系统已经运行了多长时间、目前有多少登录用户、系统在过去的1分钟、5分钟和15分钟内的平均负载。该命令的一般格式为：

uptime

例：


4:43pm up 1 day, 5:51, 2 user, load average: 0.01, 0.01, 0.00

与用户有关的命令

\subsubsection{passwd命令}
\label{sec-1.17.2}


出于系统安全考虑，Linux系统中的每一个用户除了有其用户名外，还有其对应的用户口令。因此使用useradd命令增加时，还需使用passwd命令为每一位新增加的用户设置口令；用户以后还可以随时用passwd命令改变自己的口令。该命令的一般格式为：

passwd ［用户名］

其中用户名为需要修改口令的用户名。只有超级用户可以使用“passwd 用户名”修改其他用户的口令，普通用户只能用不带参数的passwd命令修改自己的口令。该命令的使用方法如下：

输入passwd< Enter>；

在（current） UNIX passwd:下输入当前的口令

在new password:提示下输入新的口令（在屏幕上看不到这个口令）：

系统提示再次输入这个新口令。

输入正确后，这个新口令被加密并放入/etc/shdow文件。选取一个不易被破译的口令是很重要的。选取口令应遵守如下规则：

口令应该至少有六位（最好是八位）字符；

口令应该是大小写字母、标点符号和数字混杂的。

超级用户修改其他用户（xxq）的口令的过程如下，


New UNIX password:

Retype new UNIX password:

passwd: all authentication tokens updated successfully


\subsubsection{su命令}
\label{sec-1.17.3}


这个命令非常重要。它可以让一个普通用户拥有超级用户或其他用户的权限，也可以让超级用户以普通用户的身份做一些事情。普通用户使用这个命令时必须有超级用户或其他用户的口令。如要离开当前用户的身份，可以打exit。

该命令的一般形式为：

su  ［选项］ 使用者帐号］

说明：若没有指定使用者帐号，则系统预设值为超级用户root。

该命令中各选项的含义分别为：

c 执行一个命令后就结束。

- 加了这个减号的目的是使环境变量和欲转换的用户相同。

m 保留环境变量不变。

例1： 变成root用户

\$ su -

password: 【输入超级用户的密码】

例2： 变成xu使用者，并执行一个命令就结束。

\$ su xu  -c “rmdir cat1”

\subsubsection{free命令}
\label{sec-1.17.4}


free命令的功能是查看当前系统内存的使用情况，它显示系统中剩余及已用的物理内存和交换内存，以及共享内存和被核心使用的缓冲区。该命令的一般格式为：

free ［-b | -k | -m］

命令中各选项的含义如下：

-b 以字节为单位显示。

-k 以K字节为单位显示。

-m 以兆字节为单位显示。

例：

\$ free

total used free shared buffers cached

Mem: 63076 32020 31056 8204 16360 6048

-/+ buffers/cache: 9612 53464

Swap: 64476 2240 62236
\subsubsection{shutdown命令}
\label{sec-1.17.5}
shutdown命令可以安全地关闭或重启Linux系统，它在系统关闭之前给系统上的所有登录用户提示一条警告信息。该命令还允许用户指定一个时间参数，可以是一个精确的时间，也可以是从现在开始的一个时间段。精确时间的格式是hh:mm，表示小时和分钟；时间段由“+”和分钟数表示。系统执行该命令后，会自动进行数据同步的工作。该命令的一般格式为：

shutdown ［选项］ ［时间］ ［警告信息］

命令中各选项的含义为：

\begin{itemize}
\item k 并不真正关机，而只是发出警告信息给所有用户。
\item r 关机后立即重新启动。
\item h 关机后不重新启动。
\item f 快速关机，重启动时跳过fsck。
\item n 快速关机，不经过init程序。
\item c 取消一个已经运行的shutdown。
\end{itemize}
需要特别说明的是，该命令只能由超级用户使用。

例1：系统在十分钟后关机，并且马上重新启动。

\# shutdown C r +10

例2：系统马上关机，并且不重新启动。

\# shutdown C h now

\subsubsection{sync命令}
\label{sec-1.17.6}
sync命令是在关闭Linux系统时使用的。

用户需要注意的是，不能用简单的关闭电源的方法关闭系统，因为Linux象其他Unix系统一样，在内存中缓存了许多数据，在关闭系统时需要进行内存数据与硬盘数据的同步校验，保证硬盘数据在关闭系统时是最新的，只有这样才能确保数据不会丢失。一般正常的关闭系统的过程是自动进行这些工作的，在系统运行过程中也会定时做这些工作，不需要用户干预。

sync命令是强制把内存中的数据写回硬盘，以免数据的丢失。用户可以在需要的时候使用此命令。该命令的一般格式为：

sync
\subsection{使用及配置 Xwindow 系统及 GNOME 或 KDE 桌面环境}
\label{sec-1.18}

\subsubsection{X　Window　工作方式}
\label{sec-1.18.1}
X　Window的工作方式跟Microsoft Windows有着本质的不同，MS Windows的图形用户界面(GUI)是跟系统紧密相联的.而X Window则不是,它实际上是在系统核心(kernel)的上面运行的一个应用程序。

X Window的运行分为四层.最底层的是X Server(服务器)，提供图形界面的驱动,为X Window提供服务。上面的一层是用于网上通信的网络协议--X网络协议，这部分使远程运行X Window成为可能。只需要在服务器上运行一个X Server,而客户机(Client)上运行更上一层的程序,则可以实现X Window的远程运行。再往上的一层是称作Xlib的低层函数接口，介于网络和和基础系统于较高层的程序之间。应用程序的实现是通过调用这一层的函数实现的，最顶层就是管理窗口的窗口管理器了，也就是一般所说的WM(Window Manager)。在这一层的软件是用户都比较常接触的,比如fvwm、AfterStep、Enlightment以及WindowMaker等等。

X Window的运行是一种客户机/服务器(Client/Server)的模式，服务器用于显示客运的应用程序，又被称为显示服务器(Display Server)。显示服务器位于硬件和客户机之间，它跟踪所有来自输入设备比如键盘、鼠标的输入动作，经过处理后将其送回客户机。这样，使用户甚至可以在MS Windows的机器上运行X Client，截取并传送用户的输入，只是将X Window的屏幕输出显示在用户的屏幕上。客户机的输入和输出系统跟X服务器之间的通信都是遵守X协议的。
\begin{itemize}

\item X　Server\\
\label{sec-1.18.1.1}
存放在/usr/X11R6/bin/下面,并且都由XF86\_打头，一般来说，会提供单显Mono，标准VGA和SVGA的驱动，分别命名为：XF86\_Mono，XF86\_VGA16和XF86\_SVGA，另外可能还会有NVIDIA和其他一些带有图形加速功能的显卡的驱动。
系统是使用一个名为X的符号连接去访问具体的X Server的。这个X也同样是存在于/usr/X11R6/bin/目录中。

\item 配置文件\\
\label{sec-1.18.1.2}
一般这个文件是存在于/usr/X11R6/lib/X11/目录下，在/etc或者/etc/X11目录中有它的一个符号连接。它是一个文本文件，可以使用vi对它进行修改。
\end{itemize} % ends low level
\subsubsection{远程访问Linux下的Xwindows}
\label{sec-1.18.2}
\begin{itemize}
\item 修改linux配置\\
编辑/etc/X11/xdm/Xaccess，增加访问主机权限

修改/etc/X11/gdm/gdm.conf，找到下面的信息：

[xdmcp]

Enable=0

修改为：

[xdmcp]

Enable=1

并确保以下信息存在：

Port=177

修改/etc/inittab，确认启动了GDM或者KDM。

id:5:initdefault:

x:5:respawn:/usr/bin/gdm

\item windows上的X server\\

有很多软件在windows上实现了X server的功能，例如Xmanager，Hummingbird Exceed，cygwin X server，以及Xming X Server for Windows。前两个都是商业软件，需要付费使用；cygwin和Xming是免费软件。

Xming:
\href{http://sourceforge.net/projects/xming/}{http://sourceforge.net/projects/xming/}

Putty:
Configuration->Connection->SSH->X11->Enable X11 forwarding->localhost:0

在远程控制台中启动程序：

gedit

就可以在windows系统上看到程序运行了。

\end{itemize} % ends low level
\subsubsection{VNC}
\label{sec-1.18.3}
在开源领域，远程遥控技术的代表就是VNC了。VNC(Virtual Network Computer，虚拟网络计算机)是一套由AT\&T实验室开发的可操控远程计算机的软件。根据主控端与被控端的不同，VNC软件可以分为两个部分，分别为VNC Server与VNC viewer。前者是安装在被控制端上，而后者被安装在主控端上。VNC软件不仅是开源的，而且是跨平台的。有不少系统管理员喜欢在Windows平台上使用这个VNC来作为远程管理Linux服务器或者客户端的工具。

整个VNC运行的工作流程如下：

(1)VNC客户端通过浏览器或VNC Viewer连接至VNC Server。

(2)VNC Server传送一对话窗口至客户端，要求输入连接密码，以及存取的VNC Server显示装置。

(3)在客户端输入联机密码后，VNC Server验证客户端是否具有存取权限。

(4)若是客户端通过VNC Server的验证，客户端即要求VNC Server显示桌面环境。

(5)VNC Server通过X Protocol 要求X Server将画面显示控制权交由VNC Server负责。

(6)VNC Server将来由 X Server的桌面环境利用VNC通信协议送至客户端，并且允许客户端控制VNC Server的桌面环境及输入装置。
\subsection{使用 GNOME 或 KDE GUI 应用程序完成一般的工作}
\label{sec-1.19}

\subsubsection{GNOME}
\label{sec-1.19.1}

GDM  登入管理

gedit   文本编辑器

Gnome Terminal  终端模拟器

Evolution       电子邮件客户端与个人信息管理

Empathy gnome即时通信软件

Totem   多媒体播放器

Nautilus        文件管理器

GIMP  图像处理
\subsubsection{KDE}
\label{sec-1.19.2}

KDM  登入管理器

KWrite  文本编辑器

Konsole  终端

KMail  邮件客户端

KMPlayer  视频播放器，或作为Konqueror的插件

Konqueror  文件管理器、网页浏览器

KWord  文字处理，类似Microsoft Word
\subsubsection{Other}
\label{sec-1.19.3}

Chrome

Mozilla firefox

OpenOffice

\subsection{了解和使用电子邮件及相关应用程序}
\label{sec-1.20}

Evolution邮件客户端

Kmail

Thunderbird
\subsection{使用打印命令和相关实用工具}
\label{sec-1.21}

\subsubsection{cups服务}
\label{sec-1.21.1}

安装CUPS打印服务软件

在浏览器的地址栏输入： localhost:631

出现CUPS管理页面，进行相关配置
\subsection{安装 Linux}
\label{sec-1.22}

U盘启动的制作.doc
wisDPS服务器安装手册v1.5.doc

\section{Red Hat Linux 系统管理及安全课程:}
\label{sec-2}

课程目标：能快速的掌握Linux系统管理的关键要领。

Kickstart 自动安装 Linux

管理一般系统硬件

建立及维护 Linux 文件

配置 NFS 客户端及 autofs

理解系统及服务初始化

掌握用户及工作组管理

将工作站与提供共享网络服务的现有网络整合

设定工作站，作为 NIS,DNS 及 DHCP 服务的客户端

管理 Linux 打印子系统

利用 at 、 cron 及 anacron 自动化各项工作

维护及解释系统日志

对文件系统进行磁带备份并把系统压缩并存

利用 RPM 安装、升级、查询及删除软件包

配置、编译及安装 Linux 内核

配置 XWindow 系统和 GNOME 桌面环境

执行基本的性能、内存及程序管理

配置基本的系统安全

进行基本的故障检修

\section{Red Hat Linux 网络管理及安全课程:}
\label{sec-3}

课程目标：介绍Linux服务器软件的应用以及安全管理，通过实际的应用案例指导企业用户如何安全的使用Linux服务器软件的网络服务，包括服务端的安装、配置及管理以下各项共享网络服务:

DNS/BIND 域名服务

Windows(tm) 客户共户的 SAMBA 档案及打印

NIS

Apache 万维网服务器

DHCP

sendmail

NFS

ftp

pppd

\section{其他内容}
\label{sec-4}

使用 Linux 进行安全管理

安全管理措施入门

指定安全策略

局域网安全维护

文件及文件系统安全维护

密码安全及加密通信

程序安全及系统监测

以服务为基础的安全及防火墙

以 Linux 为基础的安全工具


\end{document} 